{
    "version": "15.1.4",
    "vulnerabilities": [
        {
            "id": "a2d5171bdb83017fe9f863eadb360359b7102164b0a085f2da7ae067f7960a40",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:172:172",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/generate-catalog-info/generate-catalog-info.ts",
                "start_line": 172
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "6f0d31b2b6ed04ab904439ab04b99328a1f1685e7a0e300ceda2897c835cc483",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:276:278",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.ts",
                "start_line": 276,
                "end_line": 278
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "93c29d16f160b8544cc8fb83aad25dedc1d5facb9b70f9aa7fb575587d8aeb47",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:375:375",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 375
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "cf683a1c74a760d8ea9699b5ebfacca09e7a6659cddef73587b79a32690e1b33",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:37:37",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/generate/server.ts",
                "start_line": 37
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "798b7e6ed8a09e6acd40ef59e186a161b6ef10872367303ce6fa0ee8ed2b156e",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:390:390",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 390
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "618606989a1b4a4d6cec2cdd60654dca4267098c9bc3e4bacfa04d7f1df0a23f",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:39:41",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/fuzz.ts",
                "start_line": 39,
                "end_line": 41
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "7a0e7bb5f5b6659bd4eabb9687f50bf0feaa01a99cdd8f0177f6f2c4d2468637",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:404:404",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 404
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "fcfcdf3b2951ceac87009ff971c1865bb0ee5ef2eb8a5890fe4edefae7b03a6c",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:422:422",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 422
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "e52f2494ce0b4a0db514bb21aabb0a9bdcd229a474e4eef94614a133c4195689",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:439:439",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 439
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "e48f001b60a154d08e28f9965178c92fee66f306c1e5cacf1a65e745998388c1",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:50:50",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/lib/openapi/helpers.ts",
                "start_line": 50
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "1256ce1476dd06c6ea748c389834d572d3ca1d279c7408573f9cc062daf9bf93",
            "category": "sast",
            "name": "Deserialization of Untrusted Data",
            "description": "User controlled data in 'yaml.load()' function can result in Remote Code Injection.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-yaml_deserialize:53:53",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/mkdocsPatchers.ts",
                "start_line": 53
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-yaml_deserialize",
                    "value": "nodejs_scan.javascript-eval-rule-yaml_deserialize"
                },
                {
                    "type": "cwe",
                    "name": "CWE-502",
                    "value": "502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                },
                {
                    "type": "owasp",
                    "name": "A08:2021 - Software and Data Integrity Failures",
                    "value": "A08:2021"
                },
                {
                    "type": "owasp",
                    "name": "A8:2017 - Insecure Deserialization",
                    "value": "A8:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-yaml_deserialize",
                    "value": "User controlled data in 'yaml.load()' function can result in Remote Code Injection."
                }
            ]
        },
        {
            "id": "5b44041789a15fc56be3728b91055e390454ac90b84bf83a5e112146ef7db5e1",
            "category": "sast",
            "name": "URL redirection to untrusted site 'open redirect'",
            "description": "Passing untrusted user input in `redirect()` can result in an open redirect\nvulnerability. This could be abused by malicious actors to trick users into \nbeing redirected to websites under their control to capture authentication\ninformation.  \nTo prevent open redirect vulnerabilities:\n\n- Always validate and sanitize user inputs, especially URL parameters\n or query strings that may influence the flow of the application.\n- Use allowlists (lists of permitted URLs) to validate redirect targets \n against known, trusted URLs before performing the redirect.\n- Avoid directly using user input for redirecting. If unavoidable, ensure\n strict validation against an allowlist.\n\nFollowing is an example of secure validation against allowlist to prevent the vulnerability:\n ```\n // Define a list of explicitly allowed URLs for redirection\n const allowedUrls = [\n     'https://www.example.com/page1',\n     'https://www.example.com/page2',\n     'https://secure.example.com/page3'\n ];\n\n app.get('/redirect/:url', (req, res) =\u003e {\n     const url = decodeURIComponent(req.params.url);\n     const isAllowed = allowedUrls.includes(url);\n     if (isAllowed) {\n         // If the URL is allowed, proceed with the redirect\n          res.location(url).status(302).end();\n     } else {\n         res.status(400).send('Invalid redirect URL');\n     }\n });\n ```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-redirect-rule-express_open_redirect2:109:109",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/auth-backend-module-pinniped-provider/src/module.test.ts",
                "start_line": 109
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-redirect-rule-express_open_redirect2",
                    "value": "nodejs_scan.javascript-redirect-rule-express_open_redirect2"
                },
                {
                    "type": "cwe",
                    "name": "CWE-601",
                    "value": "601",
                    "url": "https://cwe.mitre.org/data/definitions/601.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-redirect-rule-express_open_redirect2",
                    "value": "Untrusted user input in response header('Location') can result in Open Redirect vulnerability."
                }
            ]
        },
        {
            "id": "9e03be5b9eeebb59b2a5b21879390db10849b0c658bda77c57dc394988aab622",
            "category": "sast",
            "name": "URL redirection to untrusted site 'open redirect'",
            "description": "Passing untrusted user input in `redirect()` can result in an open redirect\nvulnerability. This could be abused by malicious actors to trick users into \nbeing redirected to websites under their control to capture authentication\ninformation.  \nTo prevent open redirect vulnerabilities:\n\n- Always validate and sanitize user inputs, especially URL parameters\n or query strings that may influence the flow of the application.\n- Use allowlists (lists of permitted URLs) to validate redirect targets \n against known, trusted URLs before performing the redirect.\n- Avoid directly using user input for redirecting. If unavoidable, ensure\n strict validation against an allowlist.\n\nFollowing is an example of secure validation against allowlist to prevent the vulnerability:\n ```\n // Define a list of explicitly allowed URLs for redirection\n const allowedUrls = [\n     'https://www.example.com/page1',\n     'https://www.example.com/page2',\n     'https://secure.example.com/page3'\n ];\n\n app.get('/redirect/:url', (req, res) =\u003e {\n     const url = decodeURIComponent(req.params.url);\n     const isAllowed = allowedUrls.includes(url);\n     if (isAllowed) {\n         // If the URL is allowed, proceed with the redirect\n          res.location(url).status(302).end();\n     } else {\n         res.status(400).send('Invalid redirect URL');\n     }\n });\n ```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-redirect-rule-express_open_redirect2:91:91",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/auth-backend-module-oidc-provider/src/module.test.ts",
                "start_line": 91
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-redirect-rule-express_open_redirect2",
                    "value": "nodejs_scan.javascript-redirect-rule-express_open_redirect2"
                },
                {
                    "type": "cwe",
                    "name": "CWE-601",
                    "value": "601",
                    "url": "https://cwe.mitre.org/data/definitions/601.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-redirect-rule-express_open_redirect2",
                    "value": "Untrusted user input in response header('Location') can result in Open Redirect vulnerability."
                }
            ]
        },
        {
            "id": "4519011e5bbcbb8f5a93793f785e34e37ab1f00666119dff712c891678afadd1",
            "category": "sast",
            "name": "URL redirection to untrusted site 'open redirect'",
            "description": "Passing untrusted user input in `redirect()` can result in an open redirect\nvulnerability. This could be abused by malicious actors to trick users into \nbeing redirected to websites under their control to capture authentication\ninformation.  \nTo prevent open redirect vulnerabilities:\n\n- Always validate and sanitize user inputs, especially URL parameters\n or query strings that may influence the flow of the application.\n- Use allowlists (lists of permitted URLs) to validate redirect targets \n against known, trusted URLs before performing the redirect.\n- Avoid directly using user input for redirecting. If unavoidable, ensure\n strict validation against an allowlist.\n\nFollowing is an example of secure validation against allowlist to prevent the vulnerability:\n ```\n // Define a list of explicitly allowed URLs for redirection\n const allowedUrls = [\n     'https://www.example.com/page1',\n     'https://www.example.com/page2',\n     'https://secure.example.com/page3'\n ];\n\n app.get('/redirect/:url', (req, res) =\u003e {\n     const url = decodeURIComponent(req.params.url);\n     const isAllowed = allowedUrls.includes(url);\n     if (isAllowed) {\n         // If the URL is allowed, proceed with the redirect\n         res.redirect(url);\n     } else {\n         res.status(400).send('Invalid redirect URL');\n     }\n });\n ```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-redirect-rule-express_open_redirect:229:229",
            "severity": "Critical",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/local.ts",
                "start_line": 229
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-redirect-rule-express_open_redirect",
                    "value": "nodejs_scan.javascript-redirect-rule-express_open_redirect"
                },
                {
                    "type": "cwe",
                    "name": "CWE-601",
                    "value": "601",
                    "url": "https://cwe.mitre.org/data/definitions/601.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-redirect-rule-express_open_redirect",
                    "value": "Untrusted user input in redirect() can result in Open Redirect vulnerability."
                }
            ]
        },
        {
            "id": "37635a940394f469fe685abcadc9485871585b6fb85e67dd74f1dd1c6724315d",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "User controlled data in eval() or similar functions may result in Server Side Injection or Remote Code Injection\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-eval_nodejs:80:80",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/scheduler/lib/util.ts",
                "start_line": 80
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-eval_nodejs",
                    "value": "nodejs_scan.javascript-eval-rule-eval_nodejs"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-eval_nodejs",
                    "value": "User controlled data in eval() or similar functions may result in Server Side Injection or Remote Code Injection"
                }
            ]
        },
        {
            "id": "b83f66719581b2f0a8cd9bbd77c58fce6108dcdad50e252bd24b4f9d7da4cbfc",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "User controlled data in eval() or similar functions may result in Server Side Injection or Remote Code Injection\n",
            "cve": "semgrep_id:nodejs_scan.javascript-eval-rule-eval_nodejs:97:99",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/scheduler/lib/LocalTaskWorker.ts",
                "start_line": 97,
                "end_line": 99
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-eval-rule-eval_nodejs",
                    "value": "nodejs_scan.javascript-eval-rule-eval_nodejs"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-eval-rule-eval_nodejs",
                    "value": "User controlled data in eval() or similar functions may result in Server Side Injection or Remote Code Injection"
                }
            ]
        },
        {
            "id": "0e92c2b432c3d7e46d3a2f64b8e9a24d6bbf42b6f2ba383114391d567793c1c8",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:102:102",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketUrlReader.ts",
                "start_line": 102
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "5226765d1f6ac960319e75ca1c11fc55370e074fd09b19e8596ac6078547d94d",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:124:124",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-confluence-to-markdown/src/actions/confluence/helpers.ts",
                "start_line": 124
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "a5096d50d604f7f329f8a09f59e03da821cc1d85a6ff98ca16b3f0ec53b8dec4",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:126:126",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AzureUrlReader.ts",
                "start_line": 126
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "4559f37eb288d7c61e026c6f559636bf803b90abaeeddeabf86e3532f57a6463",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:126:126",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/FetchUrlReader.ts",
                "start_line": 126
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "e5b53e966b28ff15be0fdd952be3156a53ac7e660c4ede5c51bd23e24c77214f",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:137:141",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.ts",
                "start_line": 137,
                "end_line": 141
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "575eda33c42c9af85ce70bb87d014d729abcc80a98824cfe9fac972d35436f63",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:138:138",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/HarnessUrlReader.ts",
                "start_line": 138
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "f7ca08dab008dd6ff230a83ec5b866480ffc3c8b8bcf511d571850f913cbbb80",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:139:139",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GiteaUrlReader.ts",
                "start_line": 139
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "fbbb58ae0e0274099a403dc57d79ff8174be257ac236e737bf7d0400792c66d2",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:141:141",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GerritUrlReader.ts",
                "start_line": 141
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "9d6c60f1edc78eb2a05d774a13df0af534928a4e852cdb92cd10a274bf513159",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:141:141",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-gitea/src/actions/gitea.ts",
                "start_line": 141
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "1a48c91b12b6899fcae5eb8ef937f66b1c2a656b9e2395597d485dce517f72df",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:142:142",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AzureUrlReader.ts",
                "start_line": 142
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "0092d725e628466e0b85c2b101f29421d32d968f2267f53bbf8f638d34786d3b",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:142:142",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketCloudUrlReader.ts",
                "start_line": 142
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "50241068b67e4edd1834733c914f3a2f3a57e829dadccffdf3bb0564417b66d7",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:144:144",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-import/src/api/AzureRepoApiClient.ts",
                "start_line": 144
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "7f897a86d08e3a9a60b43fc4edb167972810471e1ccd1422388c5be2aea93b20",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:144:144",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/integration/src/gitlab/core.ts",
                "start_line": 144
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "9a4a308b47cf445fd27f8c09e6b65130b8b385941844818289d646884e9d5012",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:153:153",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketUrlReader.ts",
                "start_line": 153
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "2644a06a7c03e5228f8e64d9c4afc4ae066a24119da2c80d71c0eabf3725743b",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:162:162",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-import/src/api/AzureRepoApiClient.ts",
                "start_line": 162
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "1e0044d77c5ef8379cbd8f228d5d0101c3224e7c83d629e0393d0d50d8a02764",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:164:168",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.ts",
                "start_line": 164,
                "end_line": 168
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "967cea50d55162b785207299d0c27013a3d3b03ba8320b44968747a94f648d98",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:192:192",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GerritUrlReader.ts",
                "start_line": 192
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "87040ffed4fe9f6e0ec6eb0ab614962c66f9524ec51dd4c2c4432678352ce924",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:200:202",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.ts",
                "start_line": 200,
                "end_line": 202
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "1b9e566c59a294da70b4ab13c474b004ef16a724d36d3d082f21aaa366bba6a1",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:231:231",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-msgraph/src/microsoftGraph/client.ts",
                "start_line": 231
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "ef86dd99efb2fc03490cf97941d1d30c0fb20bac48b9dc248cd375b86447f880",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:241:241",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/kubernetes-backend/src/service/KubernetesFetcher.ts",
                "start_line": 241
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "3547b07a2e2d5821d95857416ad861596df94d02ffbb11d2a8f8110b8a393ca8",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:307:307",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/generate-patch/generate-patch.ts",
                "start_line": 307
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "f0c9ae8ce4622ba61c030b3cb216683a00c371fa0fdcf46ec22c27eabc77b196",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:32:32",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-bitbucket-server/src/lib/BitbucketServerClient.ts",
                "start_line": 32
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "2bcdbfd106adc7c4e9a7a75cffdf1cc2adb8bda64c2b6dc3ee6f2382bd9dfa8a",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:336:336",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GithubUrlReader.ts",
                "start_line": 336
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "5681522425bc2bd51514f98e5291592bf88539c82ea061e54995bdd3ae6708d9",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:354:354",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gitlab/src/lib/client.ts",
                "start_line": 354
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "d57dc21af585f0c99ba755717b36210c02ce75500d22ff1be26972247b975d3e",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:36:36",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/integration/src/bitbucketCloud/core.ts",
                "start_line": 36
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "6f5b4c027d2ab2866bdbc952cd6b14499c189ae5d18fc4fd2582d7a3e5350192",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:38:38",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/integration/src/bitbucketServer/core.ts",
                "start_line": 38
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "42b0448854f7bda891852c36ce7d01fc7f077d41e79f79af13b23368b3bd632a",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:402:402",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gitlab/src/lib/client.ts",
                "start_line": 402
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "5503f97017c4f3d099b4f893a3790dacde5f6bccade14f731283922c3a0efc40",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:41:41",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/integration/src/bitbucket/core.ts",
                "start_line": 41
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "6cf9fb699b814ca01958c5e7cd609210f4999e73598d91c5e4b997d6b1baa2b5",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:440:440",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gitlab/src/lib/client.ts",
                "start_line": 440
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "c012bdd7d8832a77a238ebb291a9dc558684a06db994343570a140e03cb7e1bf",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:46:46",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/integration/src/bitbucketServer/core.ts",
                "start_line": 46
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "c426c3112b7936a157647ee5a40c0a77df9c75cf0dffd60393fa3ea94f1e8ad3",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:47:47",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/integration/src/bitbucket/core.ts",
                "start_line": 47
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "0da524825ba5bfbe97c11688df9e4cdd6217706c02fc1f77c46ac79fc09902b8",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:49:49",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-puppetdb/src/puppet/read.ts",
                "start_line": 49
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "cb26a0ce625db2024b52b9ac2815d16a53607c65c5f4e370b97d9d1fe5afcc1a",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:50:50",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-gitea/src/actions/gitea.ts",
                "start_line": 50
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "d3db939f5802feaa208e3b8b72e78b70a580e98705f3cd1d53a232d22f7820ea",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:50:50",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketServerUrlReader.ts",
                "start_line": 50
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "2c3e6ae5c697a5467d9776a955c909947bf8fae0187a5a4f5f0817cd235beaef",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:54:54",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/create-app/scripts/add-lock-seed.js",
                "start_line": 54
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "402ee4ace115cf7b9d6282dfed0e60f262122e62bf37e4a114bd519499200993",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:60:60",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-gerrit/src/actions/gerrit.ts",
                "start_line": 60
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "7eedf03ee9a6f843d7be7b4d263f334205080af1088f76004f003a5ca6f39d8b",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:68:68",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs/src/reader/transformers/addBaseUrl.ts",
                "start_line": 68
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "58de58596f82775342786d733648aeaacdb6cdb284dab596487863af634e5d6a",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:74:74",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-backend/src/service/PermissionIntegrationClient.ts",
                "start_line": 74
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "f5e21841a42f3d4e035e7a8811d7a542c11ecd638e4765762dc625ff178393d2",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:76:76",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.ts",
                "start_line": 76
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "16462f77a57d706c7fb2a9e2cd778bbdd69c7e87d3b4e4056121d6a028d6d44c",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:79:79",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-gitea/src/actions/gitea.ts",
                "start_line": 79
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "82135bf57ed03994c2f9adf33f17da684d47979316ccd9be15438bc01bb503b8",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:82:82",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GiteaUrlReader.ts",
                "start_line": 82
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "af05ad39df62e896bc65711e172de38f145acb9e7d6342a5a138bc919b82a266",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:84:84",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/HarnessUrlReader.ts",
                "start_line": 84
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "c5ad12b9f3a323c867504802f8741cf4f3fa7a16483baab7e6e0e7450ee1ca61",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:86:86",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AzureUrlReader.ts",
                "start_line": 86
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "2f2cfb32f620dce1ed89178f0efdfc7c426f90e09ffe12c3017bd29628ed4a7d",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:89:89",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/kubernetes-node/src/auth/PinnipedHelper.ts",
                "start_line": 89
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "4968e9157efea779afeb25f0b5ea41b118293478f5245d6391185698bb07c8ef",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:91:91",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketCloudUrlReader.ts",
                "start_line": 91
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "956ac43e47f93fa2ddaef0ea820e5d4f8cb28bb4f5a20e65512a52b67cbb4c1a",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:96:96",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GerritUrlReader.ts",
                "start_line": 96
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "086097411de88280fa63721d6a283af02ef93918ceb8be601cd4590ec525e376",
            "category": "sast",
            "name": "Server-side request forgery (SSRF)",
            "description": "This application allows user-controlled URLs to be passed directly to HTTP client libraries. \nThis can result in Server-Side Request Forgery (SSRF).\nSSRF refers to an attack where the attacker can abuse functionality on \nthe server to force it to make requests to other internal systems within your \ninfrastructure that are not directly exposed to the internet. \nThis allows the attacker to access internal resources they do not have direct access to.\n\nSome risks of SSRF are:\n\n- Access and manipulation of internal databases, APIs, or administrative panels\n- Ability to scan internal network architecture and services\n- Can be used to pivot attacks into the internal network\n- Circumvent network segregation and firewall rules\n\nTo avoid this, try using hardcoded HTTP request calls or a whitelisting object to \ncheck whether the user input is trying to access allowed resources or not.\n\nHere is an example:\n```\nvar whitelist = [\n  \"https://example.com\", \n  \"https://example.com/sample\"\n]\n\napp.get('/ssrf/node-ssrf/axios/safe/3', function (req, res) {\n  if(whitelist.includes(req.query.url)){\n      axios.get(url, {})\n          .then(function (response) {\n              console.log(response);\n          })\n          .catch(function (response) {\n              console.log(response);  \n          })\n  }\n});\n``` \nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n",
            "cve": "semgrep_id:nodejs_scan.javascript-ssrf-rule-node_ssrf:96:96",
            "severity": "High",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/auth-backend-module-aws-alb-provider/src/helpers.ts",
                "start_line": 96
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-ssrf-rule-node_ssrf",
                    "value": "nodejs_scan.javascript-ssrf-rule-node_ssrf"
                },
                {
                    "type": "cwe",
                    "name": "CWE-918",
                    "value": "918",
                    "url": "https://cwe.mitre.org/data/definitions/918.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-ssrf-rule-node_ssrf",
                    "value": "User controlled URL in http client libraries can result in Server Side Request Forgery (SSRF)."
                }
            ]
        },
        {
            "id": "8153cf2f8c857f271826dd628b6d8ee5cd8316fa29a49a0af2202592bcdf464a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:1004:1006",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-dynamic-feature-service/src/manager/plugin-manager.test.ts",
                "start_line": 1004,
                "end_line": 1006
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a26ca87bd96d69809e3306e37b733b406c808a90239390133320cb17fb481575",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:100:100",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli-common/src/paths.ts",
                "start_line": 100
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b118af0fa777177d6b8b2681eaefeeefa149d595d8e1e38d9b3ff0f6253b7ba3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:100:100",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 100
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "206520cd609e21a3f5cd5f2aa8a99b4e50856733251e57d7fae1bbdaf79cd93c",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:100:100",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/cache/SuccessCache.ts",
                "start_line": 100
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f9e47b219885b610db750af23523bb811e226e56ca5c454fbc486b58bc4b907a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:101:101",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ReadableArrayResponse.ts",
                "start_line": 101
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "18a33ce012810019c84f870d38b5f912d569cc9694f828d709bc1e922790b569",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:101:104",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/type-deps/type-deps.ts",
                "start_line": 101,
                "end_line": 104
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e9613a03a243c6263343bc8abf41d6eeeef374c4da05bfa8ddd9b158cfe51b96",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:102:102",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ReadableArrayResponse.ts",
                "start_line": 102
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "62b60af45aaf5566e0993d08c10e066594540e5157c7d613027e5193a4705f83",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:102:102",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 102
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3024a96a1eda4e2d932c88ebac5ec9a380a0d367a6c228b649c61500742b3965",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:104:104",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 104
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b9eabf01a01a6a95c1c4d256094086e2d98e18b02ea96f4ac8f5542da096d4ca",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:105:105",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/delete.test.ts",
                "start_line": 105
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f1394f8d684ecd28557a950bcf16b7e645fda997aff2d8bbc1b075e0d81fdedd",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:105:105",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-rails/src/actions/fetch/rails/railsNewRunner.ts",
                "start_line": 105
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d03732cb9f56529d90bbd37a2d7c0664b2270eac163a18a0ed0890fab9fae1f3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:105:105",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/openStackSwift.test.ts",
                "start_line": 105
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "eb22b8394049c6ab43f065ed67507d4d9a67926f443b824ebcf3468ce888be65",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:105:105",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/backendModule.test.ts",
                "start_line": 105
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c271564308fa73baae121dc376fce4b1a21029030aa36b8467702cc9ab5710ef",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:106:106",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/common/tasks.test.ts",
                "start_line": 106
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d678c41cc2c7d09b890c1d92f3cd9e5ad4a16b5b5d63179bd0048f6f50f2c3a9",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:106:106",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/scaffolderModule.test.ts",
                "start_line": 106
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7410a4a4606650dfcaa782c9c9fafef2cb2bd24cab2ab3e737c2f1c383e7140a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:107:107",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/list-deprecations.js",
                "start_line": 107
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "dc5b036c9e12e063583c8ad295e1813b3b0c80c3dd200967da4644f26ab5f3c1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:1089:1091",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-dynamic-feature-service/src/manager/plugin-manager.test.ts",
                "start_line": 1089,
                "end_line": 1091
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a38c9dcfe20a7d03c4152dcb7592cbfbfdc2f585a0a7029cd452cfbb24a12a90",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:108:108",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/list-deprecations.js",
                "start_line": 108
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4c9a916bc086ed8555a9feb15bdaeeb48e977426368bf98002049c1791f3de0b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:108:108",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 108
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "88db95c780b9dba308d61e8dd5c716dc017432e55c37fa4366811b6d557d2eef",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:109:109",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/create-app/src/lib/tasks.ts",
                "start_line": 109
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "9a14ecad9664c8810787393c864228b6f17e0468b9998958d9bbfb279d81e7c5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:113:113",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/delete.test.ts",
                "start_line": 113
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fa964b74ec233821a8e407ecc16818e7bd484e7cc2df615e1db94078935f028c",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:113:113",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-confluence-to-markdown/src/actions/confluence/helpers.ts",
                "start_line": 113
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "11e0fa4c12dd025f0b1ac7cd9cf6fb575ee6011043b03728401feaeb949098aa",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:116:116",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/DockerContainerRunner.ts",
                "start_line": 116
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "36dcfbf690c950aa0ebc3311c47e879e1c6fb183326d13d1c652a06f0ea2e9e3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:118:118",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/common/tasks.test.ts",
                "start_line": 118
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "345c4d7f623ecdfc58ca03c9d33f8d9cda70e27263bd131353cee375aff59d1d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:118:118",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/frontendPlugin.ts",
                "start_line": 118
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "ad62fc5f8adfd6a77d914c78abc4404eb8fe2f12fe5c26dd297ce641ef9ef43c",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:119:119",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/tasks.ts",
                "start_line": 119
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "adb1a70d9f88d2d2c26571624e712200122013e449029c0dc755233ccc7aa632",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:120:120",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/DockerContainerRunner.test.ts",
                "start_line": 120
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "1115540baeee275b375a2dcb113dd092cf1745aefbda2af00754c6904a8648e5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:120:120",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/backendPlugin.test.ts",
                "start_line": 120
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e7b3e786935076d20c79b016447705a79bce9ed90a40b6a7ca532a34b8d8adbb",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:121:121",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/DockerContainerRunner.test.ts",
                "start_line": 121
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d98f9cc272525aa280be1332210c597881a6f386145f20236d15dccd533dcfda",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:121:121",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/common/tasks.test.ts",
                "start_line": 121
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7e8c7f77c4f850ba0eb39f06a74bb1ca8fa68c1977091709c394bc7ec7edbac1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:121:122",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli-common/src/paths.ts",
                "start_line": 121,
                "end_line": 122
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "0496445c6111d0385ba05fcd4b630f2dae5b61070c15a1ac537bac5bc7da64d6",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:122:122",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/templateFile.ts",
                "start_line": 122
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "6f0495a4401b9c0a89fd1d533c70161f90bbbe75c9b41e318c8d145ba3448e9c",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:122:125",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/backendModule.test.ts",
                "start_line": 122,
                "end_line": 125
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3d135ba8acb6c9b78945e1776695f6590afae895004b2f2ec3bea437ee833758",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:124:124",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/frontendPlugin.test.ts",
                "start_line": 124
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "644c6634dfca6f2b30ce59c406a48042058a2e285dcd097e2dbb1a4c7b417c3f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:124:126",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 124,
                "end_line": 126
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e24520194804ce1f658bd2a0300bbcb984a7513909213fe3a80468adf50e7e6a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:124:131",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/bundler/packageDetection.ts",
                "start_line": 124,
                "end_line": 131
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "75f798cc6b5af05b610928cee9488d0f73d8967ca598c165811e12d0f4f255b2",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:125:125",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/create-app/src/lib/tasks.ts",
                "start_line": 125
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b1576bdc77410029ed6f8bc14a1557b2469905d94597153492ebd21896703a2a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:125:125",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/openStackSwift.test.ts",
                "start_line": 125
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "af119d96da483362076d6cd370221c459ff81f65a2bc804968f62590c6556312",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:125:125",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/knip-reports/knip-extractor.ts",
                "start_line": 125
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d6c5cd64e28d64ec6cbd6b5a770cf4baea1db6c9fdeec5e26672ec3e0faa77f9",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:125:125",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 125
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "846b9b3532c006fe9e9a57991a5ab1ce410b7ea5ad71ad07ebbc6a930b698656",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:125:127",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-confluence-to-markdown/src/actions/confluence/confluenceToMarkdown.ts",
                "start_line": 125,
                "end_line": 127
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "98480d9150641ae789dbc7dc2e3714d2c67225dd9eb63dae8e0f7dfbaa7c2dce",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:126:126",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-cookiecutter/src/actions/fetch/cookiecutter.ts",
                "start_line": 126
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "85419c72f4473b74b7eb872a15e6d21d2337eff56922c0588295ced387ca9714",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:131:131",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 131
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "50a8ce186ddfde9526e6cef5a7c07738755d6e770c589c9579bd1a326b0988e7",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:131:131",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 131
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7b29de931ee4b414238e59192e138d131287e79f0b972358e94b8a9e9bcd112a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:132:135",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/templateFile.test.ts",
                "start_line": 132,
                "end_line": 135
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "5f177176a0eae36a5057c5c11b862bd0ce33bd5ee15263be576612e056879bed",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:134:134",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/local.ts",
                "start_line": 134
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3f8ce150324a80cbda8df2cd8b6b68e82f9d9b0e4609e049b5254960ec0be00b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:134:134",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 134
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "0fa8b0e2b36f4cedf5f558a8161cb961531ef349fde59d9fa2aa201bd85c59da",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:134:134",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/codeowners/codeowners.ts",
                "start_line": 134
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d2f66b707e5fcfc589da21e704f39ced4a5ac8db962d4647cb45369608bef156",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:135:135",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/knip-reports/knip-extractor.ts",
                "start_line": 135
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "6033c337fed5f42a85fb5156ac671b7568d6af55d153d5757a391ea564b3fc78",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:136:136",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/local.ts",
                "start_line": 136
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "61ae2a465d8fb9bf1e2413669472077f187849110c6d69d33a2fbcc9966d9c68",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:137:137",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/tasks.ts",
                "start_line": 137
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c0689e05b24a6326a68b7523643cb3e3e15249cb93c2221964f592d1e4a787e1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:137:140",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 137,
                "end_line": 140
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3cd51ad414b2b4725271aa39052bd3eca718f48a1e0c08fcc75273c3f4648b59",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:139:139",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/packager/productionPack.ts",
                "start_line": 139
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "8fedba32af07084e54e2344338472c9b9dca5cba75074e5713b0e8836c0bbc01",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:139:141",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 139,
                "end_line": 141
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "05b4b4e663dc8f021fa8ac790278a9babe8716374e2477982e0c58aa6c137d05",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:1418:1419",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 1418,
                "end_line": 1419
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d1b15fb6a44aa1c88735bda148488db8e2c2d5fbd052eb9c2eac4389c63426c5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:141:141",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.test.ts",
                "start_line": 141
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "95e20fce90eaeae61a418784080f515d7c6a1b9affe8c7295c54c990056951b9",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:142:142",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli-common/src/paths.ts",
                "start_line": 142
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b5403f33cf7537e73c9b26ab5c70f5794c8189c5cc8a9274234b1f23fc0422d5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:1430:1430",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 1430
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "041470bb00841f889fc71e3f3409f0a75f382cb9f7a3fb474cc94782e4e345ca",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:143:145",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketServerUrlReader.test.ts",
                "start_line": 143,
                "end_line": 145
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "cd31bcb773568b822179ebcd3ca4a1813a6488b06b4456f3fae6dfb185c99a78",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:145:145",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/list-deprecations.js",
                "start_line": 145
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c760e6c94ad89db275ff40b7e3e8fb5164be6016906959a4f80205b203c97694",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:146:146",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 146
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "5c05059a527652d2c91f05398045ddb479c9e94830c1e82c3ebcacb52c340c08",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:147:153",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/lib/templating/SecureTemplater.ts",
                "start_line": 147,
                "end_line": 153
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "16089db4459376093919c02d5089efd6209764d95dd56c3f066aa10f1ca32390",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:1481:1482",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 1481,
                "end_line": 1482
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "6dcec2c09af8623e391cbe84fd5c70a382e88f1d60a0dcd9ad80e86889918644",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:148:148",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 148
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4a36cf79c4488223ab58864950b6748d4a02d7b601976a281b6631ec216c8ce6",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:1493:1493",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 1493
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4175d331e408778678a8dc729112ca2ca544e24a405cbb36b3341a3f24e0d650",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:152:152",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 152
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "36b76d7f9565fd6df2a824a583f2a12a40c48d6501c9023072827174cf5dabc5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:152:152",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 152
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "902aa175f3cd460373550d5bbecdf5399ab31818215ce829c95f8dea094c4afd",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:152:154",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 152,
                "end_line": 154
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "24d57963dada31714285f7c51f6c0bf4f26433e55e93086ef031172a0746a809",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:153:154",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/build-plugins-report.js",
                "start_line": 153,
                "end_line": 154
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e8ec4be1cca75de12cf8aae6eae6d22f029fd931bdccdc069ded78663e22eeb9",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:154:154",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/type-deps/type-deps.ts",
                "start_line": 154
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "9af8be39a7f059c57d6883e3ad4cbba9e206100234a67b685803bd237919ac0d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:155:155",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 155
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "6d6d7c9a33ff18236a3eaf37b2dddf06b46005aa328c065995e09cf4af860b19",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:156:156",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/verify-local-dependencies.js",
                "start_line": 156
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "71fca0634d5dfbb633b413ae47b652f11e16809ccd7c3408eb166867040627d4",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:157:157",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.test.ts",
                "start_line": 157
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4f8b9190108c45f28908b2900359fc44495f30f0b9169066e7cc64da296bea8b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:157:161",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/type-deps/type-deps.ts",
                "start_line": 157,
                "end_line": 161
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a5b05739c5f47ed9e6feab5c5a4d565559d2934a60d57254cf4a673a47a38f79",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:158:158",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 158
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "5dae478f5b7e6c2ca6d8b7b04d21629ac39229a2c2bd8b3abe6fef0e46116497",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:161:161",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/templateFile.ts",
                "start_line": 161
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "2bfe97fa9f26da3b1dfc3628c2340efa4c1e04d8aef600e722fdf3ef79dec2fd",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:162:162",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-confluence-to-markdown/src/actions/confluence/confluenceToMarkdown.ts",
                "start_line": 162
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "406181a407be5b63ae212d243e8a5b69a80f0e867b312131a281179adfd46a20",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:163:163",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-confluence-to-markdown/src/actions/confluence/helpers.ts",
                "start_line": 163
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "8557d912da5b77f6abebbdb5a7a543a085104e5505d70ca475bb14de8f7b9c94",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:164:165",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 164,
                "end_line": 165
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "439a073542b3373f436e7ba85a6dcc406b195078b16034420c9b57efa011640e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:164:166",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-confluence-to-markdown/src/actions/confluence/helpers.ts",
                "start_line": 164,
                "end_line": 166
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "8351f0534e968cc490a2dd5fe358e5747838df56f78eee1c5e2a770b136d657b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:165:165",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.test.ts",
                "start_line": 165
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "94bab9a012a3da183caa9d25b1014232b04e0b3835198f68ad499418dd1182ae",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:172:172",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-backend/src/DocsBuilder/builder.ts",
                "start_line": 172
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a722cf51aee05ef1acd208f68ab0e4095ff9af84977f228ddddbffcea5ae3fe0",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:172:173",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 172,
                "end_line": 173
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "812e5e084f5df8defd7fe3ea20e3b8641e257c86803a708280a7204064c1df66",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:173:173",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.test.ts",
                "start_line": 173
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a714fa6331278ab3831b49e4218b67abe01bb6a7376dd0626c3a8503da40c832",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:173:173",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/templateFile.test.ts",
                "start_line": 173
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "36cb7a833b7ba41bca95476d4fee3cf6e011b2f88ce1d51b2e3ec219c54bcec5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:175:175",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/openStackSwift.ts",
                "start_line": 175
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f93866fb3a5ee27fe2e8c5af64d9f1b4ef94e945458958fb5da8f61ecc361c6e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:176:178",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 176,
                "end_line": 178
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "12f3a7180128cd89ffde5785924657d528bfc64054e9a49539d1e567d4014475",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:178:178",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 178
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e553762a9e6bc1c8754ae8567d31e44a4a87895301517b5a0e6010c05118a315",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:180:182",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 180,
                "end_line": 182
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "93b899a98f0665516ac855d7c0b4570e0de4bee9e4bb4322b3e8b58368673e43",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:184:184",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.test.ts",
                "start_line": 184
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "05d8aa5b3cabd3629ed145a742f9ac5a0dc31ff952be557aff3b3a69ef594890",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:185:185",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.test.ts",
                "start_line": 185
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "72c1186345576ae421b8d992f69720ec1555959e5eb6f531df05011fa3585756",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:187:190",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.ts",
                "start_line": 187,
                "end_line": 190
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "78ec8106fc2231c651f7b83f8d72f549fc9d6414e3889263e3c7cb0e696add76",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:188:189",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 188,
                "end_line": 189
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fc215e3c9e79cd4d29d6c3a1ae9c954876deaab4b3376e3175b83e60086c01f2",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:190:190",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/frontendPlugin.test.ts",
                "start_line": 190
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b6c730bf0d1a14399f2a706f7c0fed4f9554da87b06246fc3d00d77c7597d6ce",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:194:194",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 194
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7bc2d087c9503971972d7173513c8e26c793ee854598995c7fcb97bb8bd47ba7",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:196:198",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AzureUrlReader.test.ts",
                "start_line": 196,
                "end_line": 198
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "ce4e813a716f7343b533cead062dd0abfbc966792827734be3ff7115872cee49",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:200:200",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 200
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "de9e3f00b398352744becdbc93aac5d992b6cfadcbb3fab87ebc54e2404a736f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:202:202",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.test.ts",
                "start_line": 202
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "2580c329af4c57cbdcbba47b5abbea5bfa909c69d885f54c990eca9fe399e139",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:202:204",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketServerUrlReader.test.ts",
                "start_line": 202,
                "end_line": 204
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c906128a2abd9e7d9618d32eda8cc0be55e44bbf1f5b4592aa051d10b53b04be",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:204:204",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/awsS3.test.ts",
                "start_line": 204
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "397ff9e43ed407fda8852aa0f3da30b21af362fc519a271e4bd13523e646683f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:205:205",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.ts",
                "start_line": 205
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3886f917e9b0fa026eb5a5c113965067d97ff8440988402abb1f8939015d898a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:205:207",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 205,
                "end_line": 207
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d5c1b2406dbea8635bd0e6161cc74e0d057542947b9bd7c698c04f17908f9f7e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:210:212",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/HarnessUrlReader.test.ts",
                "start_line": 210,
                "end_line": 212
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4f7d7bbf2b08a90bc064ec19b2d4389e9ce3be1145fee5660ac123c24e38a054",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:211:211",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/templateFile.test.ts",
                "start_line": 211
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "98a449a9d3e34c1717251e588da56031d6b4fcede46e710c8970764e25d0e07c",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:216:216",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/tasks.ts",
                "start_line": 216
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "57e1ab2e57d0ee2e74f809f3331ef2ef977698a63716072e712ffb7208043970",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:218:218",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.ts",
                "start_line": 218
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "1439c41477dc8a9c72de066afe962f1ecfc4445c358586f871a89af962a399f2",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:220:220",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 220
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "34d7478b20f9877bc165005e547919ad863e7211aadd49df03f07d78cd0427d3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:221:221",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/devtools-backend/src/api/DevToolsBackendApi.ts",
                "start_line": 221
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "bad2479946028bd481649f3092d6ee365e98a5b8deb3f47749d73bc3fbd96290",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:222:222",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/devtools-backend/src/api/DevToolsBackendApi.ts",
                "start_line": 222
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "cc08a8a87e507434c388aded6d02d55cd4069d21b4bb253f2e8481d8facfe7f0",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:223:223",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 223
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "ed8e5f0cfe2388b854374da475df3db269a4cc7c3c35ab58a5735b0a13a46efe",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:228:228",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.ts",
                "start_line": 228
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d6ab70d978aeca741c5ec72e670489d31cc512aea0440048265ed64545468bc8",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:229:229",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/tasks.ts",
                "start_line": 229
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f9b0e6413e3465e2026c63e5d7acbe4ef2494577e6595bed03b82d33294137f1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:22:22",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/auth-backend/src/migrations.test.ts",
                "start_line": 22
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "2726a0f9ca369e4129b6db10d89be9e982b865a2c4ef0108fdd31b16f34d4a48",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:22:22",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/migrations.test.ts",
                "start_line": 22
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "9410f94f9dc7da47a19ef93e6421a732a401e9b74289d6e796b48a49d8295f65",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:22:22",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/events-backend/src/migrations.test.ts",
                "start_line": 22
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c8534810049587e7a3b79a5a9aff48f4f7a3d07b71a142401c2d4ce943c23e95",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:22:22",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/app-backend/src/migrations.test.ts",
                "start_line": 22
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "98912161a14fce3d9661daaee3c0e243a25157025e7934193bba8c78d5090b29",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:22:24",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 22,
                "end_line": 24
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "239eeccf6dfd82ff91ea43e1dffbac167cf3a257a72e19207b97ca3ff25d0c98",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:231:231",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 231
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "624113f5598e677f2cce3d391fdd8314d60b1d1ff6098ade3a1c48a012271c16",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:235:235",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 235
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7f9e5e90cc82daab94db72c76c1b72ad61c581b7c72b09f0146a89e33cbdc611",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:238:238",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.ts",
                "start_line": 238
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "26ccf6be7f5a401dac201372de98a82ce595f26bb3bbcbce36981970cad7cb81",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:240:242",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 240,
                "end_line": 242
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "6a51281a6e4f84b6a89e0e4bfea89760baf699a524d19a7e558ae13f5e56d8f0",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:240:243",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/versions/migrate.test.ts",
                "start_line": 240,
                "end_line": 243
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3c49ba40f9bb4074f4273a53224e51182fb671e8f73cb07b3ecaa96b953e2217",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:240:249",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 240,
                "end_line": 249
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "ac203f023d79858f7fe730afb7fb2a957687f90004d355bbefc89ad61ae468de",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:242:247",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketCloudUrlReader.test.ts",
                "start_line": 242,
                "end_line": 247
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "17f3501f1d9cb28d891ec2f36f2639a28cd3fcb8f5a4a762011cf21e2ee86f9f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:244:244",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 244
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fb46c8b99a8e5149e1ac6e0e757cfec83759ebe58ef0e1e5a7e58748756fc887",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:244:244",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/templateFile.test.ts",
                "start_line": 244
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "435eec4b029496d933be3b381472b54bc87f4dcef069630ae011bc655f880878",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:248:248",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.ts",
                "start_line": 248
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "60840becb81ec57680a865b6c75925a5e77f496b3f874c72bea0a43de664cd17",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:249:252",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/versions/migrate.test.ts",
                "start_line": 249,
                "end_line": 252
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e419255afd69206d550f7af72fb6b98ab5fbd44891c78e551f21f7727dc7269d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:24:26",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 24,
                "end_line": 26
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "2d30b69c8bc5eac0698047a5ac36e1f988e8fa257b2714d36f77134f5eb83150",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:251:251",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-test-utils/src/filesystem/MockDirectory.ts",
                "start_line": 251
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "034670440938daecc16a4adc4bb8d7a89cbbf40b018715a43a954a609c30281b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:252:252",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/config/jest.js",
                "start_line": 252
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c89be0faede33c3cb16f81f70980039cd8776e195aeb5217f56e43056b1a73bb",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:253:253",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/lint.ts",
                "start_line": 253
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "306df62bfdf285fef718e359c8a15eb7027cbd42ae72cf5623a9a362faf47ac3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:253:255",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.test.ts",
                "start_line": 253,
                "end_line": 255
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "62d213ca0f94d36f7d20748beac60f635f0d5e3ec2763ffeb2e1f8ed74c7eb80",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:254:254",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/generate-patch/generate-patch.ts",
                "start_line": 254
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fc7394d504c51c6b637d90798d519e6cb0e50f94940c280ffb305c7511fdde3e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:254:256",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GerritUrlReader.test.ts",
                "start_line": 254,
                "end_line": 256
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e291d141032d5472f760f9af2ad8e32d5dec7b8bf5acd82634c079c0e6e5ed1c",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:257:257",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-test-utils/src/filesystem/MockDirectory.ts",
                "start_line": 257
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "32642d41a871013c77aa6edb3e867f5bf35bdfc7791cd52f370d876a0db4f71f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:259:261",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GiteaUrlReader.test.ts",
                "start_line": 259,
                "end_line": 261
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "aff41517bb48ff1becc8396fbf3dc3eeaf5c8a26b4a507a080b4ba2cb1d2d603",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:25:27",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ReadableArrayResponse.test.ts",
                "start_line": 25,
                "end_line": 27
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "765f53ab839fd31d93ceae60bc65827c71ac1b8ac3bf4a1870b814ced925cc66",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:263:263",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/bitbucket-cloud-common/scripts/prepare-schema.js",
                "start_line": 263
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "1e19b68461b0cfc9f22aed3fbdadfe66031e7e42ff8b080c4564a651c887bba1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:263:265",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GerritUrlReader.test.ts",
                "start_line": 263,
                "end_line": 265
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b6c00cd42412b7a7f96eda15d0e34c29ca52c89ed2e18e7ba1339236213fad99",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:266:268",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GerritUrlReader.test.ts",
                "start_line": 266,
                "end_line": 268
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "8aa4fc5021105153290e5de480020766bbc68cec5d25200f2e0ca9fbebd86f28",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:268:271",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 268,
                "end_line": 271
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fb1fa0e1f6d05c2598e1710e2ebbd15b919208854e04cf6f0592dd29804cfdbd",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:269:269",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AzureUrlReader.test.ts",
                "start_line": 269
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "bb561330a998b94be163802a9c00d14fcbd541df9be8ac56315a1a18df232534",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:269:271",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 269,
                "end_line": 271
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "90966eceb6c001bba56579219845b3be36db1039e9ee1c426eea70db2ce42397",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:272:272",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AzureUrlReader.test.ts",
                "start_line": 272
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "bc3fad7bc33ffdbced2ffad850795962b1dc0059b48a10d7a490267731f7b570",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:275:277",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gerrit/src/providers/GerritEntityProvider.test.ts",
                "start_line": 275,
                "end_line": 277
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "8ead246bf2da56e529c8298932ff8acea91e6f8919b0decb9767bc68b2723c5a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:277:282",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AwsS3UrlReader.test.ts",
                "start_line": 277,
                "end_line": 282
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "66c70e1c0fb5271cde8f28b96f1c517e0b1a1241da58956a71411994e51ed25e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:27:27",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/lint-legacy-backend-exports/lint-legacy-backend-exports.ts",
                "start_line": 27
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7175e4e8efd5684528e6ab95aad2b1fe46d82d7ab5102a6a0d956900e39f57f1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:27:27",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/info.ts",
                "start_line": 27
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f2421d61108d3c0e8492242b7cbdd5ee1ee7b0c41a222e04e72e248ee11101fa",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:27:29",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 27,
                "end_line": 29
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "15e64e22528f60e901ae58dd2b785d989a86f36c4ed1aaebaa3e5b07d736d01b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:285:285",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-test-utils/src/filesystem/MockDirectory.ts",
                "start_line": 285
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "51f7d4a0624769a681c9eac7f44cd79328868061f3b3f0e3e8ac3c56f75df1fa",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:288:288",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.ts",
                "start_line": 288
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "394d60bd15a4390711a8f2b2207fa4ae90ee93c4d2f1489d0462f11064a6136f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:290:295",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketUrlReader.test.ts",
                "start_line": 290,
                "end_line": 295
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "5a88bd1d85dd31382877cc88926a4a1183f800a9d7127acf5ba05b43ecb7354b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:293:293",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-test-utils/src/filesystem/MockDirectory.ts",
                "start_line": 293
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f9d72e82a884482e6bf069442686eb62227f9ccd487a89573e671a7a915ee3aa",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:294:294",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 294
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "2da1ad1cc45d66701bb0d5c41d79a34dcedc74291d3880db2d7914b9b126acf1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:294:296",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 294,
                "end_line": 296
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "154857cd241a73731d79075ba9e0f9b39bf3a5f998cd5b73f451cf888f6e3437",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:295:295",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 295
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "12ae5d4705bf3a6b8787f83494a3124921f81d7d8c577ce187ed145c8ecf9dc2",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:297:299",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketUrlReader.test.ts",
                "start_line": 297,
                "end_line": 299
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "42abc60e9073663b49bf14b117f449d7b8de4363b1bffc3cad76e75bea4f2923",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:29:29",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/app-backend/src/lib/config/injectConfigIntoStatic.ts",
                "start_line": 29
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "878e1eb199b3bd4e2d40afd30f8cdfdfb17037f4083cdc3fd572ee1107c417a1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:300:300",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 300
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f820cd18427fcf7aeb32fcb74aa4518fa9f3a901ccc4c250f8f17498c9355961",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:305:308",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 305,
                "end_line": 308
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a45ea4258ace691462a82fbc170a06fffbfc3e24f57e955736e022e7dfe7da99",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:306:308",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AzureUrlReader.test.ts",
                "start_line": 306,
                "end_line": 308
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "8fa26d51a621be30c5bb854ebdd9cff725394da979cb4316be611ba157038135",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:306:309",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 306,
                "end_line": 309
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "57bccc5cfa027d8a70046a60e38ec725ce33bcc13ebb1c2a9042f43ee2f994b2",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:308:310",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GithubUrlReader.test.ts",
                "start_line": 308,
                "end_line": 310
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4bbd3875cd21deeab3194e97440bdbdc71b528e80c10a3c39f38003fb388d80f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:30:32",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 30,
                "end_line": 32
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "968a562a5ae42b9e22bb46bf59cca907e0e006b7dff4e8e862013afc3fa1c26a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:30:32",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ReadableArrayResponse.test.ts",
                "start_line": 30,
                "end_line": 32
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "994255db5f01b2f93413d50a1af6fa1993c7401a1f0790643aa10a3bd15ce4f4",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:313:313",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.ts",
                "start_line": 313
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e5d5f2136a75e7aa6f61b86a6e9a39e5cfc4cd60e6a955fa23025b80d9a881aa",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:315:315",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 315
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a1fa8c0820c31d7adc393d38c8b48b11e01444561d9008a8ddb3ce2a0c5adbb9",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:315:315",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketCloudUrlReader.test.ts",
                "start_line": 315
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "ab2a48b0254f2131ba929a4ae38437213f2a08b2c6c9dc457b975addc87228be",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:316:316",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/generate-patch/generate-patch.ts",
                "start_line": 316
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "80c1e7cacea78c2c064fb9380082931b4b2af142bcc35392c6a406bc5b51f811",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:317:317",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.ts",
                "start_line": 317
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "564188474e950f79e2461d8b48be1ce2696eb5a4709a4718abe13df60a9bf83a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:318:318",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/kubernetes-backend/src/service/KubernetesFetcher.ts",
                "start_line": 318
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7376ed15864f94a8f8e4e4d0852a961dd434580856777df6d06020ef17b225b0",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:318:318",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketCloudUrlReader.test.ts",
                "start_line": 318
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "77416cb94e45a0c90760425faccff325de772f907b634904ad594f751ea7d905",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:319:321",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 319,
                "end_line": 321
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "daf890dd4bf4971eeb3f693f9bec466c83bca4c4628b0e2d87ace92c5ea182e1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:31:31",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/info.ts",
                "start_line": 31
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b4c5782eb1c34cb41f75fe5a6bd7e806ebb086fb22ac5bfeb33cfc878ecb17b9",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:320:320",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/awsS3.ts",
                "start_line": 320
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "313a46eaabf0960d19902775f0d794d01d2559f07255e95068b6efc856268231",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:321:321",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 321
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "cf0932f31045136cc0372759841c25d3e80d3c63d62a889db9b7a590c64b858d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:325:330",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AwsS3UrlReader.test.ts",
                "start_line": 325,
                "end_line": 330
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "75a61cfc63501f68a94030310af9be04612d3c9004092661a10ee53cb08f3e24",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:326:333",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/create-app/src/lib/tasks.ts",
                "start_line": 326,
                "end_line": 333
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f930ea1963736d608e90b7443656535e9ee82bd75d8f50e9d4d8527f56bae48a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:327:327",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 327
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "5b4aa323e50be16e3904ae4fb88de4c645affb8f07d33bf0ec469db256b5b42f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:327:330",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/versions/migrate.test.ts",
                "start_line": 327,
                "end_line": 330
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c04b801171a8548fec33dbf00ddd2fc2a7fc2ba2b587b4a827544bb9cf310294",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:32:32",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/list-no-top-level-material-ui-4-imports.js",
                "start_line": 32
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "45c19113af410ae7ef8166cc6d4cbb545b47388bd4bf3370ab644ad8d0dffe0f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:32:32",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/config-loader/src/sources/FileConfigSource.test.ts",
                "start_line": 32
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3ea2c5a56bf3bac6d6024d5c8149b2414e161fa66ab3b7a2ef5c54a4996a8859",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:333:334",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 333,
                "end_line": 334
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "31205fe5080722c781630998e4234b532745fa74515597bf73e3d48d3b8df358",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:335:338",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 335,
                "end_line": 338
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d13c192705c2f9d1381e3a89ba9b354c22ad413ee010abc37505f641efee601e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:336:339",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/versions/migrate.test.ts",
                "start_line": 336,
                "end_line": 339
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "16b1dde5f87d0e17a40408c25ba689e43e89227ba4eea9ad8bec5f85221ebf4e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:33:33",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/sort-package-json.mjs",
                "start_line": 33
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "18b7d5aab675d5bf8b2d8808776aeddd87733505537adcd282ce1b39b6d61261",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:33:33",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/app-backend/src/lib/config/injectConfigIntoHtml.ts",
                "start_line": 33
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "79ae389eb151541ba7465656df0c1e205b01249053d81c6a09bbcd77e8771510",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:33:35",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 33,
                "end_line": 35
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "73c3c379174428a6d5647e2b706014e52163ab4a5b723821a024880f22e9e027",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:341:342",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 341,
                "end_line": 342
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e67bec888eb420f4d39e41ac4ca2020d607dc1609e664a7d4bb6ce1212053be5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:343:343",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 343
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d77bec0400f598582dd95cb9ef01c7fd91d8767b3167048c0d7aae4d86b54f5e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:344:346",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 344,
                "end_line": 346
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "150df7e90395cba6c93f7a27a62188f03e0b90f613cb38820c1ee92910033bb8",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:345:345",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketCloudUrlReader.test.ts",
                "start_line": 345
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "9c9f738cdfe121a50677583f065b50852e8771826c27a7119419a64e260237d3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:345:348",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/generate-patch/generate-patch.ts",
                "start_line": 345,
                "end_line": 348
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "06a8da5d844f87e283bf2b2fd5481cc926a8d10d1921ad1384b014bb7a3ff83f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:346:346",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/prepare-release.js",
                "start_line": 346
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b871ac7b26a97a2357525a72e9d47a96794bc11856efb9ad17595e544ee731e6",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:347:347",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 347
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "327b73e546c9cd007c9d888ab77a3da9873247f2517012b1cb669db8433ebbde",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:349:351",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 349,
                "end_line": 351
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "ef266be3edba299554bf71fcd106cc2a89a5c636d8ce705b2b58d1c8abe7ccf0",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:353:353",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/prepare-release.js",
                "start_line": 353
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fb5cc44db26079e81eba61cd2477e7c45e45193a4529f71f3fdbf185176ab715",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:357:357",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 357
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "337467a43b0ac6c95ea943bf969f0e30b9325a77aecc9cf1ca94b1bab6ea86d3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:357:358",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 357,
                "end_line": 358
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "6c93800a9cfc432d1b1f8f5bcec0fa3609c9f387bb495fda1fc14909e1b30121",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:363:363",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 363
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a6ca516e6f14cd15d8ba72f6e7fad9d75e7203ec08bf65c9dbd7199651e3e17e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:36:38",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ReadableArrayResponse.test.ts",
                "start_line": 36,
                "end_line": 38
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "69d72c8066e28004d7b2d575dbe3fb087dd77ef8b88bee4ccd732fd6754c1b61",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:370:375",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketCloudUrlReader.test.ts",
                "start_line": 370,
                "end_line": 375
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "bfa75ab4b80f99731ad496f200353ca659cd057ab46e0c936e4bd86a87503d46",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:372:374",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 372,
                "end_line": 374
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "6674f3c5f83678a7561c8afa0fe67e7e117d02629a92fb08a109c75424fd6ee1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:378:378",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/generate-patch/generate-patch.ts",
                "start_line": 378
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fce5065b536faa73024091058c387c6aafe7b0e9b5583818363e699f11392309",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:37:37",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/generate/server.ts",
                "start_line": 37
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "1f48ad30ca5440dcb493f354ed5096291dd387d4eaa1bf817c7180ff03d2e1c1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:37:37",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/files/deserializeDirectoryContents.ts",
                "start_line": 37
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b2e4406e5472b1fefae0b453672911db99d16ac33460a63647d260f55384e3f9",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:37:40",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/app-backend/src/lib/config/injectConfigIntoHtml.ts",
                "start_line": 37,
                "end_line": 40
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "9bebf60d177df40639d46dc48550faa27f55f98a25109fd5b0d46705d50cd1e1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:383:388",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AwsCodeCommitUrlReader.test.ts",
                "start_line": 383,
                "end_line": 388
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "04c04f5a3a65dc776a1186c92c344f341eea975eac3781e0482dc3cc19d6c402",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:386:391",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AwsS3UrlReader.test.ts",
                "start_line": 386,
                "end_line": 391
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "0162820623600ec47218b03779193bfa51388686f71e7b62f5d28dc2e9034348",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:387:389",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 387,
                "end_line": 389
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b69dc63b8a3c0172968a764d55483e368e3597cb9a725eb1ab3e0f0235daee0f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:389:389",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/prepare-release.js",
                "start_line": 389
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "dc2a1c6a4efb7c161399e4ce39d6347a0d524458d4a679047b040180d9d692ae",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:389:389",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/config-loader/src/loader.test.ts",
                "start_line": 389
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "589506aaeea277f86a63f6f45276bd7310baa2c82cc16c0f6c40e1003d5915d1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:38:38",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/app-backend/src/lib/assets/findStaticAssets.ts",
                "start_line": 38
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c3b243d8b295a761c73ce0d7c88d5b93f15f43ca467b1001616a97f0b44b3afd",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:38:38",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/app-backend/src/lib/config/injectConfigIntoStatic.ts",
                "start_line": 38
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a6f6096b132a55fd1a28cc8c365b76cf85937e269f0ecf7b82b162c55074ca5d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:38:40",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 38,
                "end_line": 40
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7f6548641b0d04c0eff3d127cbf8154a72c150e640dab399b7105a274a63913a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:38:41",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gerrit/src/providers/GerritEntityProvider.test.ts",
                "start_line": 38,
                "end_line": 41
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "2cb259e49231f03d7b357cfe2e670fb2b4b670299193e164d1fd59f3f837bf4d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:390:390",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketUrlReader.test.ts",
                "start_line": 390
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "204b7958b9eb9d442bae13176860b14ff3aac8998da28f88c8f880ce63db72a7",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:393:393",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketUrlReader.test.ts",
                "start_line": 393
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "56627f4fba3507551d4159980dbc6311a0ba113121e5c2f2b8172575492cdb55",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:397:397",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 397
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "729505b9e64f6b0cb6c2e0fd844690ba43e52abd15bec244d4038639373a97f4",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:399:399",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.test.ts",
                "start_line": 399
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e5ca6d7623a22444ffdf2064210d8388f2d7b58a1af5cb61abee5ccc6a2a40a7",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:39:39",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/sort-package-json.mjs",
                "start_line": 39
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "636bfc5dc93746afc341f89a0e859a14106be9a3bc10065a998f096a42a566bf",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:401:403",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 401,
                "end_line": 403
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "65ab2f8fbc2f16ebe536060a504834afe30c58cb964a5e2f19620d157332b30d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:402:402",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.test.ts",
                "start_line": 402
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "6bc7b069e4de29e81eff3e4f5f29f8064190906da6a30b7e701d89397a92c836",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:40:40",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/fuzz.ts",
                "start_line": 40
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "672f68d3e153a8545692f2ef76901a8c3bb79a994a3b7d57e905a03b410bf1ca",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:40:40",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/config-loader/src/sources/FileConfigSource.test.ts",
                "start_line": 40
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "61cb624368de78a6f08b78111ad27f45c64f1d8b1696f6a5608faac7fdda2775",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:413:416",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 413,
                "end_line": 416
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "417467458f5307c571a5fd340af88332db28abf86fb9f56ab1f604a7b322b313",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:419:421",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 419,
                "end_line": 421
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "aed57e87a3428801f8c92890f4c67cf86f64687296fb7454cfdf6a11481fe8a8",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:41:41",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/list-ownership.js",
                "start_line": 41
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "22033089c0477402c3b1494cdce13aa5949022bc0800136c753d84c3990de263",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:422:425",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 422,
                "end_line": 425
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "655610b5dc1941555f0c67a2a27ca473ba48ab43c5d415567b7fc2efc83c4c34",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:428:433",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AwsCodeCommitUrlReader.test.ts",
                "start_line": 428,
                "end_line": 433
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d28928b2c5358c69f29b52f6d79d58b6d3fe92768d6766cc09ee416d330a26be",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:42:42",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/verify-changesets.js",
                "start_line": 42
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "417e256cd532284912f64cf8a8d337b47d2e9fc02fab67dabc8a89787f8d0e07",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:42:42",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/repo/schema/openapi/lint.ts",
                "start_line": 42
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "52330b14f98bc75defffe4f4b36a44dd482ead85d2948be04308f02ae124aa60",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:42:42",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/mkdocsPatchers.ts",
                "start_line": 42
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "052f9051d70775a1348efab540765cff92eec5a4e7da1c6f37549ff6611ea184",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:434:444",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 434,
                "end_line": 444
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "74adaf5fabbd1989d33e1740ab9962f7d75079c60d5a58b001fe2beb1d382642",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:435:435",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketUrlReader.test.ts",
                "start_line": 435
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a014f3d5f63a59be08116ec2e171cef9fbbde0bccfcd36b194fece24201821cf",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:436:438",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 436,
                "end_line": 438
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "5636c9116f56082e05642e8789f062a232f8bcd8c6173d8f68e8f4b08823e9c5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:43:43",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/packager/productionPack.ts",
                "start_line": 43
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "844cb1e3faa828ba766b611bff2fffb8734932111feb8ef874da2255d7e478b4",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:43:43",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/rootHttpRouter/http/getGeneratedCertificate.ts",
                "start_line": 43
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "8a14a64dd7c185d6baf830297f971ba7b9e1c1daba71d3efa8cc41702f6ed9f4",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:43:43",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/cache/SuccessCache.ts",
                "start_line": 43
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "87b0e4108086d63437fe2d137d33524578afbcf5a7b9bfbf6f7063fcc55edce6",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:446:446",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GithubUrlReader.test.ts",
                "start_line": 446
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "633f0c196cf087db1419d81d71bf1e08584b412b8cfa33a029af27b0b378331f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:447:450",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/googleStorage.test.ts",
                "start_line": 447,
                "end_line": 450
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "85f2c90cb46e78e880a90c55a343a326494f57a0b640cde85cfc7a7df7333fa1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:449:449",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GithubUrlReader.test.ts",
                "start_line": 449
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fd78996ef5ffd7254eedb0cf9703a838d48b88297c9896d111a54c1355abe16b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:44:44",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/list-backend-feature.js",
                "start_line": 44
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "41a03cb10eeb600ce25a12deb5bd67d1b1bb222740ac01426ad495c054722248",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:44:49",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 44,
                "end_line": 49
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "33cc396ddbe17b5872ed2d8482a74ad93c54604a4578263c8c1aed2132d7e4cf",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:44:49",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 44,
                "end_line": 49
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "45925fd192fcb47bfe2a75e5943dd9d9ff2ba22ae8b887c858b63f10836e8d44",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:44:66",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/init.ts",
                "start_line": 44,
                "end_line": 66
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "355b8da8dfd9c172c71ad2e7b4a29155003c32b74dc570582ec55d3380f2ad23",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:456:456",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.test.ts",
                "start_line": 456
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "8a50973f7084b8372d5570bc0c789b46c74aa336ae7ffba48c1c4bfe46f1cd79",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:459:459",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/googleStorage.test.ts",
                "start_line": 459
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f79019ebb1f8efbf922d534b09f01128746461c6b3faf0f3d21a6361030d4411",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:45:45",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/generate/server.ts",
                "start_line": 45
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "5d83383de8469aeda7d0a69605614de7d078f2d0e9ee70abc628521781bb323f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:45:45",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/kubernetes-backend/src/auth/ServiceAccountStrategy.ts",
                "start_line": 45
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4a607dc060f729885784e35460637ddf1021afdcba7f7891bbc0a2fd4512d9d7",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:461:466",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketUrlReader.test.ts",
                "start_line": 461,
                "end_line": 466
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "254e5ee003a835c4828f03a678a5062926f91310c09451dd701f4339c6d2201d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:462:465",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 462,
                "end_line": 465
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "39c08cd411476a3e6150f2d9ebb599dc815686bccd66d61070aef50b0e6ec264",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:466:466",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 466
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "30ce57995540828c64b36f895f86c694909340d6f60bed44e0cb4877d141467e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:466:469",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/azureBlobStorage.test.ts",
                "start_line": 466,
                "end_line": 469
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3a2f042298e5a818ddfc7b66f94541ef00322a456b5d72b05028058d8f5321d2",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:46:46",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/app-backend/src/lib/config/injectConfigIntoStatic.ts",
                "start_line": 46
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "1c1ed98d57975d0d933159e4bbd37c09275dc7f51930c68360197f73b199e2fa",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:471:474",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 471,
                "end_line": 474
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "905983935847c41ac3cce1c745023e62e0a408365662c007eae99df48c7112b9",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:478:478",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/azureBlobStorage.test.ts",
                "start_line": 478
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b68a95117a47be977fc9e998c5fb5476790a0f07e4961c8ffde16598ece69cea",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:47:47",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/azureBlobStorage.test.ts",
                "start_line": 47
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c2599824004a51cf1c587fc604357ad5efcf05e6f671e566299a4e579e719eff",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:480:480",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 480
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "9c87dac395ce575ec06e41ce4679fdd3288152fd97744cd7fd1c2d82446e01db",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:484:489",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AwsCodeCommitUrlReader.test.ts",
                "start_line": 484,
                "end_line": 489
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "1ca014a3e07b5a687d4fb1e8de03a525002799d955c73230b309d6fd1a48fc05",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:489:492",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-github/src/actions/githubPullRequest.test.ts",
                "start_line": 489,
                "end_line": 492
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d5054b34593f9f2ef90cd2f012a3b1aa762c92ebf042b616efda95b9d8a3d8af",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:48:51",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/generate/client.ts",
                "start_line": 48,
                "end_line": 51
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "af00ddd9b7ee98936da5aad8bc703ddd445b8f360c31e77ea3b8d8188c05a661",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:495:495",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 495
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "8065ba8503b0b6ace8cd0de9d078cd2abd7d2af8ea6dba1786412b9306b21200",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:496:501",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AwsS3UrlReader.test.ts",
                "start_line": 496,
                "end_line": 501
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d9e68a663bc5cabe33021272e1bf8946e1412a1171d48717b11042f8c71cc6a6",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:499:499",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/versions/bump.ts",
                "start_line": 499
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "91abda8d383568716e2041f1332faf57ef53a4a09f6d7b1d2c4748d33fd819fb",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:50:50",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/lib/openapi/helpers.ts",
                "start_line": 50
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "1ca721ee5d27a5d0d2c152469e7a83ef9c67bd31bd673d6af68358dd06a0ca5a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:50:52",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 50,
                "end_line": 52
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "418ad96b87c26b461d887478eebb46a4d1e4f9fd9a6f5d30e324cd56a0706293",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:510:510",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 510
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "cb90ce487e8f5291739349d16d559f47c6b9ad18a8fa1f3c905a0ce449206954",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:515:518",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 515,
                "end_line": 518
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "25caeb59f6aaf38e377d1cd1d36c5ee898d99620e113323327f1db62aaa889ce",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:518:521",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/awsS3.test.ts",
                "start_line": 518,
                "end_line": 521
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a09d2813217e2f6f659287cf7ded5e72be7ad8cef939b0263aebb78365d9681b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:51:51",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/config-loader/src/schema/collect.ts",
                "start_line": 51
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "042aaab17e0636028c0794d47150b9c940b00d94b27c18e009c27df48f2df177",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:521:524",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 521,
                "end_line": 524
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "200e096c2be2c8fe8df06b13140e811b22834da5633446a5c8c83ad31f124670",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:523:523",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/tasks/DatabaseTaskStore.test.ts",
                "start_line": 523
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3a36a101074c034c2ec0382f51b7d6ddffbcf7736715c44f891bf8e75d5b0960",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:526:526",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/tasks/DatabaseTaskStore.test.ts",
                "start_line": 526
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "14404fc73f0de7d833b391f446c41de201d4000b3868b3f2d6949b7f7dfc4c60",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:528:528",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/tasks/DatabaseTaskStore.test.ts",
                "start_line": 528
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a70134d6f24aec1c64b4c661c52a58320debc53e93b5e363897aa4d19a9616bb",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:530:530",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/tasks/DatabaseTaskStore.test.ts",
                "start_line": 530
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "dcb4070de81c365d70876fba09a99dab7c89ca982a35f5ccf441742f05f00ace",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:530:530",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/awsS3.test.ts",
                "start_line": 530
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d546adbc629023cb09714a9000e1f919f9b50d46cf74a9a2cecfea3fc2f933b0",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:53:55",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 53,
                "end_line": 55
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "3ded171cc46e5d3965d3eb20ea5fb87c653a13e54cb28da59b614de03db9440b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:548:550",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketUrlReader.test.ts",
                "start_line": 548,
                "end_line": 550
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "941da8f977043eb160634459b5e3fd2cc6150f90d3cb174fb31a693d5b29a442",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:548:550",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.test.ts",
                "start_line": 548,
                "end_line": 550
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "0d0878aef190b8b4437b7cf5794ed3d9b7c304417d339f7e799203335d6c10ef",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:548:551",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-github/src/actions/githubPullRequest.test.ts",
                "start_line": 548,
                "end_line": 551
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c79b24314a173a5b73711f2a6b5529d4bfe4661e1984ee5a5dabe83348fc3c0d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:54:54",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend/src/processors/FileReaderProcessor.ts",
                "start_line": 54
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "82081a2bdacb53f7b8f3cbbba9549f1b891dd50bdf077ec7933762664a0e0b8e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:54:68",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/generate/server.ts",
                "start_line": 54,
                "end_line": 68
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d0eb4cf14a7e1d05d97b5e038ea370025ba92a1daa3ab10c08c6b1ff381aa6be",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:550:553",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 550,
                "end_line": 553
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "9171ca73af888d47d3236ad029463cd9fa096685bdc8aca7486c9db98f317416",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:552:554",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GitlabUrlReader.test.ts",
                "start_line": 552,
                "end_line": 554
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "941bbf316eda5db56fac5558e0e15000e8afb7f2bc1b724c611c00bfbde671de",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:558:563",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AwsCodeCommitUrlReader.test.ts",
                "start_line": 558,
                "end_line": 563
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "470848d99ee5b5b22c828ebc3815e1dfefe0bfe1a15533204bd1d942d2241515",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:55:55",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/app-backend/src/lib/config/injectConfigIntoStatic.ts",
                "start_line": 55
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4131189c1095082851324ce08bd27567b701a9c0f4284a6b5f3c0fc795fc080d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:55:55",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/cache/SuccessCache.ts",
                "start_line": 55
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "0f665764976b2ff34be3eebcb6afa296b80eacc943545883f7773ea812b5cda8",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:55:55",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.test.ts",
                "start_line": 55
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "5c6f4b479354ae5240d1e44c04cb94573d9720db921b20511665b5ea3017bb3d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:564:564",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 564
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "9979f481ec11809b89c7c1b392886a7f2fde0ed5357c1f656eb5c2f8ec0e609f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:565:565",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GithubUrlReader.test.ts",
                "start_line": 565
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "32294501266f74378f264f0378f76119f89374d9725dddafcd8c5d28fd1bb74f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:56:56",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/list-backend-feature.js",
                "start_line": 56
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7b1eb5b8cc81538df6b9e88af06890ce8781677b3c3553fecfbedaf07d38406d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:56:58",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 56,
                "end_line": 58
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a8c108d7d0ea078b39378d72cb59016b78a63ce8ab90217deeb7f554e979c105",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:570:573",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 570,
                "end_line": 573
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "236fe272ee738bb418b5ee7d56e348d3cbab4bb1576524b292554b8c51d57980",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:572:577",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AwsCodeCommitUrlReader.test.ts",
                "start_line": 572,
                "end_line": 577
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "84a1be74ae03ef6c45ac7d91f5a239bb5e0530ed09696c6274df647ad88958c1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:579:579",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 579
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fbeb45c3a49cbaedaae288c5d954544a277fa6e9c21179982d0a16f8666f23e6",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:57:57",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/delete.examples.test.ts",
                "start_line": 57
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "2de5cabe6c9e15adbae3a4fba7320d2df68d24e3ce9aa7fc5cbbb9a291bab2a1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:57:57",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ReadableArrayResponse.test.ts",
                "start_line": 57
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "2defc8702e4a4ce5927e9563b270e4d9b5a8d78b05c78fa40f21f46f08ed9c70",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:57:57",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/lint.ts",
                "start_line": 57
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "73c664f1210fe68f211260361be96d18e117556c944f4e78107935c46ee2e862",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:57:57",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/tasks.test.ts",
                "start_line": 57
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "06a4384d38330bed05ec057064f767c27c6659a85c1f2eb4cf4f38cb5db9d54c",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:57:59",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/BitbucketServerUrlReader.test.ts",
                "start_line": 57,
                "end_line": 59
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "324efb850045925bebaeaad7d8aa4ef817e6ad24aed9e08e2f691ba9d614a850",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:58:58",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/list-backend-feature.js",
                "start_line": 58
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "eddc30b800181d8c39878b8e7ce291771dfde15c91165fb79ec8bdabc3403310",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:592:592",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 592
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "ef8f2a2292ab7e5c993ce27add4c3d9f79c97073ec22f28bf411f45286148744",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:59:59",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.examples.test.ts",
                "start_line": 59
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c1b1f9c7ef6a666a5bca5b1c90b0d861177cdfe602bcc30db72e8afd96440e8f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:59:61",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 59,
                "end_line": 61
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "861b0d02dfd4602129049634e773139ef0b1e0e2d6b6e6218bafe7f5fd1ed8b2",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:59:62",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/read.ts",
                "start_line": 59,
                "end_line": 62
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e74f3601e5a5f0f3d851e14d76e685de68c2fca131a5925058f66f035126584b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:60:60",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/tasks.test.ts",
                "start_line": 60
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f472a98282aed92052757d68cfc1cd74e1f31772ac00db90ea024085e05c2e72",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:60:60",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/googleStorage.test.ts",
                "start_line": 60
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "80f0b391b1578537841b4794fb28a46efed5e1439664e7051e6abb9b215d4d27",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:61:61",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/config-loader/src/sources/FileConfigSource.ts",
                "start_line": 61
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "6ce84dabe64dbe2f353d0cb51001101eff589be2c212e0a9ff63ed44be2a01d7",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:61:61",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/rootHttpRouter/http/getGeneratedCertificate.ts",
                "start_line": 61
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d64c2f7b6737859b17d0915a65105a1761d52255145f0fa4e69a271a853f7a0b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:622:622",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 622
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fcbc8e8ae73a4305129dc1c897ab170c0b64fd4e1fe5877808a515c65721b012",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:628:628",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 628
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "165a07e9e8ecd7f630118b583339124a87a86506721725ea6435d4af13488d0a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:62:62",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/list-ownership.js",
                "start_line": 62
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fb32b004ed2f4f14775c896d1e5bf8868d3248596654499b9d7233afb8f3abda",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:62:64",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 62,
                "end_line": 64
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "dcee3af5957dd87e5e2e104bee05f81a01f4652ce9e80fe6efe3dd0ff2404a98",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:634:634",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 634
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "652d2d6a66a941333bf522c048816036fe15e9a2b8e4af43a71aaab6f86a340f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:640:642",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/GithubUrlReader.test.ts",
                "start_line": 640,
                "end_line": 642
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "544e6c0ecdfd79427f838fa927ab27a8b0df8a736e2e2fc51322b216f5f7cf3f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:640:643",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 640,
                "end_line": 643
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "213e684d8ada46cdcacf76c7ee4e92a76ef8eb415025bc612687dfc955322261",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:649:649",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 649
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7ddc13b4d7c6cedca88c5ac25bf5a188487725a990a264b3b03766a4cdad29af",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:655:655",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 655
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4f22e8f3a1849c7fa4276c6d905f31c571f138a19ac99107212f53a6f2b26985",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:65:65",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/delete.examples.test.ts",
                "start_line": 65
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "88a8bef3b4864fa6482bb1412e3dd02dc13603bdf3704b52c4cadabdd92b620a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:65:65",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/create-github-app/index.ts",
                "start_line": 65
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d12342ec8699c149fc5a91b67e6c24b288fb308309e2b3cd0f145f57d63f0d1a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:65:67",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 65,
                "end_line": 67
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "05e6bcd13d9ad7f3ef31c384259fc0c938c8da95fb73bf9e0a944a37ad0b6aa4",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:65:67",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 65,
                "end_line": 67
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b1d4fb4f5d46971c07b6b5843ba18030f1cf5d2d3262cb3fcbc3bba90bca383f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:661:661",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 661
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4179d248abfb2ddd305f2007b94eb678ba03203df2a8cf87e7a420fbc78f3df1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:66:66",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/versioning/Lockfile.ts",
                "start_line": 66
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d0e65371f767011af4b8149051edae5f84b21f31a2e22100db620880ede34b54",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:66:69",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/migrate/packageLintConfigs.ts",
                "start_line": 66,
                "end_line": 69
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4a2d052b5ae3db1117b0a0961df9b319893c20f39863b85e0d1012650191727b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:67:67",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/config-loader/src/sources/FileConfigSource.ts",
                "start_line": 67
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "24232b13c9aee5dd77de7edb783b6d23dca3b90e8be98da564f04441afbf5ba5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:67:67",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.examples.test.ts",
                "start_line": 67
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4bc628c755087e2e944987169a9b3bee8886d8d0be8814b538b9ab725fda9f15",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:67:69",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-aws/src/processors/AwsS3DiscoveryProcessor.test.ts",
                "start_line": 67,
                "end_line": 69
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "63e59dc2b049d7b5fe48cd142780a35649dcc140d8e764cad439e6ee1758b288",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:68:68",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/create-app/scripts/add-lock-seed.js",
                "start_line": 68
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "429085adff7f71467160c322a617a702b17bf047fd45d869b91e35efee831431",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:68:68",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/azureBlobStorage.test.ts",
                "start_line": 68
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7b0a7d588ba1936ea75d5b44cc6df6b149c886a12db67c683f71273b2ce64b19",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:68:70",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 68,
                "end_line": 70
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "0278c69056d03eaf9e9132a459c4ead342c99b0a2dbd5c77ecb4553be652eba0",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:695:695",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 695
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "48957b7a8c6f3629c679d7b0e5b64686f7a4f4b7755850b7df834e505511f6ca",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:6:7",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "microsite/releases.js",
                "start_line": 6,
                "end_line": 7
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c75c05e25c85f665c3914433d7c3402b8fe187a9f0f070b9f8419d1ad06ffe72",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:701:701",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 701
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "ce0cc48e6f8de7b56dc648ea2a36a3af5a20775172407d7b41cc019225f7a7aa",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:70:70",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli-common/src/paths.ts",
                "start_line": 70
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "056621ed4030301fd7bf1c58b4824e3de76a471379b2cc62a6083ced62dcdd63",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:71:71",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/migrate/packageLintConfigs.ts",
                "start_line": 71
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "88812fa9e75a8fc1513e04832fcdf9cbcff3fbcf492d9f4a6fed45fd3f697de5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:71:71",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/debug/log.ts",
                "start_line": 71
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "565e7282acf43cc673684cefa5a22df0fbf3bc781ced7dffaaf1a57116049c79",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:71:73",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 71,
                "end_line": 73
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "9c85eeb8422d533183df8fabecac1da5942c6187aa9e966ed2890a01a0ea887f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:71:75",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/generate/server.ts",
                "start_line": 71,
                "end_line": 75
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c7e550343a916524154548452b02536463a52ea0273ef8c764f9e75fa755ca4b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:72:76",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/mkdocsPatchers.ts",
                "start_line": 72,
                "end_line": 76
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "487c942caeac0436e919b1a6a70c2083d6a1220cdaedffc9f72e54b038b1bff0",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:736:736",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 736
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e4b60cd2b7689779841cae59d8b3db082fae969662e9f315380d09151c4c90b3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:74:76",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 74,
                "end_line": 76
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fc34898682b557b2001301375c8ccfeaa8b2c6b49351fb5c2370e0c06c1937cd",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:772:772",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.test.ts",
                "start_line": 772
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "5ff82181e23619f70bf5648514ee63d5328d043608a0bb7ca986e433c418aa1f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:77:77",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/cache/SuccessCache.ts",
                "start_line": 77
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "26310d521d49d95f003567be57ba630aa201af75dae1f51b0ebbbb05c4eef675",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:77:77",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/version.ts",
                "start_line": 77
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "f6f11d8cc0dd07d2da028289bc2ce7811ebe405169f0260c48136a10d4d550e0",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:77:77",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/type-deps/type-deps.ts",
                "start_line": 77
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "68ff7b69c35a62ae190e672c6643407cd310e18661ac5e872b591ba1241cf36f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:77:79",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 77,
                "end_line": 79
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "393fab7bc0317815f3d2ee59eac7b76bf000432293693cd07a210a53543273fd",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:78:78",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.examples.test.ts",
                "start_line": 78
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "bd8b713ee93266a0ff0f9a610b8cab5996737d3a7231fc300e9298d946575961",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:79:79",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.examples.test.ts",
                "start_line": 79
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "b3374c5e666c93251c89649531536540f619da99ddc0613ad84d37107e493074",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:80:82",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 80,
                "end_line": 82
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e97de5de71fb693d621176f0ded4e3e3f3319c2bd775c2dac2aeb93f7e446ec8",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:81:81",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/create-release-tag.js",
                "start_line": 81
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "c4cb363ea9a8e27135fc4050ffa2f37b3c5edc4b3334a6bf14e295d7d5fa897b",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:82:82",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/devtools-backend/src/util/Lockfile.ts",
                "start_line": 82
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "342ddb2f2ba3cfd8980bdb881655bfa666a8fe560c76d36f4625902e4185a7f4",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:82:82",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 82
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "da64e342244a6823ba4c19334b536cefba5189a7a5930f50286d1e302782c49d",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:82:85",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/create-release-tag.js",
                "start_line": 82,
                "end_line": 85
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "62ab5d165ebed37ef48fad63785a78395861e401c978f05a869e853e404a506e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:83:85",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 83,
                "end_line": 85
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fbfdd83ba5721159b0ac21ef093a9f4b020e8565fac8aa21aeaca3c18ff7d543",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:84:87",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/knip-reports/knip-extractor.ts",
                "start_line": 84,
                "end_line": 87
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "950ca0eebe8f3b49285c9ffd19aa523265782254adcdb3e8d8993955deecf506",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:85:85",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 85
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fd2f9b63d4e3f38cc1686ab04f0070bae18d8c62db9fcde343d655517ef14e4a",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:86:86",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli-node/src/monorepo/Lockfile.ts",
                "start_line": 86
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e13cde652b0739c93be70681a5b36381e872a6aae04cf01e03dd1b37a9d4a4fb",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:86:91",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 86,
                "end_line": 91
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "d9e125769394fd77ccf47fed79174e1b1e004f3d0b9b47ab51a1d1582908a93c",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:87:91",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/generate/client.ts",
                "start_line": 87,
                "end_line": 91
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a34fec222a4dfcd9448626c6e7fd5b6b798dc43fab7ec68d631255c73656ed11",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:886:886",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 886
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "74d7611b2aae4d3c586babaa43c8f51a7b2fdb916cc7faefd212194b5c13a611",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:88:88",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/cache/SuccessCache.ts",
                "start_line": 88
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "89f11547501d82cef8f6039e5726ca3252d2d88db64f4c40f59e8fec16c8e30c",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:88:88",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 88
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fe9df6832c4858ff49ed404bd7a05f5467d4c0f517cdbe72c1ebc03b5039a52e",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:90:90",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/filesystem/rename.examples.test.ts",
                "start_line": 90
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "153294b2aa7a17b38083484f201c39057d1c3c27c8b8fb8ba253aa7c06094694",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:90:92",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/TarArchiveResponse.test.ts",
                "start_line": 90,
                "end_line": 92
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "1fde8ede71f889a03d2a3a98d4847c6088f3d130b60e9a3a2a1a6f88a5d657bf",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:90:93",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/template.examples.test.ts",
                "start_line": 90,
                "end_line": 93
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "594cdc8296f1f97077d553f5fce901e9c8b3921c8fbec5d67c30a0fe83e035dd",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:91:91",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/knip-reports/knip-extractor.ts",
                "start_line": 91
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "4fcf6770167e41ab42925743420c2cef893bb2ed8790c825e26c0146eb6e1168",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:91:91",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/codeowners/codeowners.ts",
                "start_line": 91
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "25045b91aae8259bf436ddb5acc2ec599a252c332b418eac8e1f5cbe1dc311c1",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:91:91",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 91
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "abf601e06d05559d131a365c33d6e172b26013cb8413dcbe0f349baf50f0ef72",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:91:94",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/package/schema/openapi/generate/server.ts",
                "start_line": 91,
                "end_line": 94
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a490acef72c4b7ca86df6f28d1bba98852b82bcc62e0d890acbdb1ba44d37adb",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:92:92",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/googleStorage.test.ts",
                "start_line": 92
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "a068c1dfe58f56f9b1220ae280d4e086cf8e3e1001af42dd725adea8d5cc347f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:92:92",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.ts",
                "start_line": 92
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "ad01dc801be25251b1a38ad51750feb50faf06e09efa6eaa533d617240dbc080",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:92:94",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/generate/helpers.test.ts",
                "start_line": 92,
                "end_line": 94
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "fc62deaa60357a0277dbe3e6c50d369e7579eca05acdbbcca9a6919d789f1eb5",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:94:94",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 94
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "7845cf5797474abea9dfb4b71470c72b72845b588c0e45f1054565e0ce2b1682",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:94:94",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/new/factories/frontendPlugin.ts",
                "start_line": 94
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "43cc6614cc83cdfa8c83c58571f05b4207098400a32f7446360accbbbe3cae96",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:96:98",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gerrit/src/providers/GerritEntityProvider.test.ts",
                "start_line": 96,
                "end_line": 98
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "e448101f61443a7d107a6a554771fce6a898c45d0bc836f5551ef836ebc56ab3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:97:97",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-node/src/tasks/serializer.test.ts",
                "start_line": 97
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "0f426466adbba2ab57cc8dcf0099080c3ce7e02344f4872909f1c084d6614264",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:97:97",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/cache/SuccessCache.ts",
                "start_line": 97
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "bc0e430b4766fceb5f4364efcac955bd283225959000a3023db414d7da1032b3",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "The application dynamically constructs file or path information. If the path\ninformation comes from user-supplied input, it could be abused to read sensitive files,\naccess other users' data, or aid in exploitation to gain further system access.\n\nUser input should never be used in constructing paths or files for interacting\nwith the filesystem. This includes filenames supplied by user uploads or downloads.\nIf possible, consider hashing user input or using unique values and\nuse `path.normalize` to resolve and validate the path information\nprior to processing any file functionality.\n\nExample using `path.normalize` and not allowing direct user input:\n```\n// User input, saved only as a reference\n// id is a randomly generated UUID to be used as the filename\nconst userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};\n// Restrict all file processing to this directory only\nconst basePath = '/app/restricted/';\n\n// Create the full path, but only use our random generated id as the filename\nconst joinedPath = path.join(basePath, userData.id);\n// Normalize path, removing any '..'\nconst fullPath = path.normalize(joinedPath);\n// Verify the fullPath is contained within our basePath\nif (!fullPath.startsWith(basePath)) {\n    console.log(\"Invalid path specified!\");\n}\n// Process / work with file\n// ...\n```\n\nFor more information on path traversal issues see OWASP:\nhttps://owasp.org/www-community/attacks/Path_Traversal\n",
            "cve": "semgrep_id:eslint.detect-non-literal-fs-filename:99:102",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/actions/builtin/fetch/templateFile.examples.test.ts",
                "start_line": 99,
                "end_line": 102
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-fs-filename",
                    "value": "eslint.detect-non-literal-fs-filename",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-fs-filename"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-fs-filename",
                    "value": "detect-non-literal-fs-filename"
                }
            ]
        },
        {
            "id": "480cfa4b259bdb0650c0ca3b827511984a98be4ad0296fbb8fb0ad06cb6589c8",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:101:101",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend/src/providers/DefaultLocationStore.test.ts",
                "start_line": 101
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "9af8268b1538e50bac4c13aa111d7d5d6b0e128b8db333f01ca968ca7d53cb08",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:104:104",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-bitbucket-cloud/src/providers/BitbucketCloudEntityProviderConfig.ts",
                "start_line": 104
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "b26789e679fc468577d933c277c7fee812175646986e5e907cc31c89cbd29d7f",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:121:121",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/rootLogger/WinstonLogger.ts",
                "start_line": 121
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "87831bc0d37679dc06f04a239c4208600e800a1dfebfa51bcbc168baf4960f02",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:129:129",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/versions/migrate.ts",
                "start_line": 129
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "50d52ed24455c92676db44837128538d6c3337496394c6fa62c1a146ae8a5021",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:130:130",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/versions/migrate.ts",
                "start_line": 130
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "ff8c064a24bd972edf83b6556a46d5b9ffa28662336ddf11a1a9e339a20adc31",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:131:131",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/versions/migrate.ts",
                "start_line": 131
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "44b797652f326fd340d145d29035b30f200d3be96e714805a197b5931e34be89",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:144:144",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend/src/providers/DefaultLocationStore.test.ts",
                "start_line": 144
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "4089edb468bf5fe4c48108f50a5b4520e228998f14d9c2ec3c1a10b2c77cfaa3",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:150:150",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-github/src/providers/GithubEntityProviderConfig.ts",
                "start_line": 150
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "b894599add45eebd5fb8d4f3c81e4cf14f37591e368044e9c04d5247e430fe5a",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:154:154",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/scaffolder/tasks/logger.ts",
                "start_line": 154
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "bcfb4480bf675969c5264970d81b413c23677498dc5d045157d6ea5736669892",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:170:170",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/kubernetes-backend/src/service/KubernetesProxy.ts",
                "start_line": 170
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "2f1274ba05747e08e5c63a6b72a5d4e0a90ab58825fc878511e1cb3c01c659b8",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:171:171",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-confluence-to-markdown/src/actions/confluence/confluenceToMarkdown.ts",
                "start_line": 171
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "dc2c48a84ce76d492908fbc3ed0d8d2daee1babf1ded6c3b011a1b81d406b730",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:172:172",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend-module-confluence-to-markdown/src/actions/confluence/confluenceToMarkdown.ts",
                "start_line": 172
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "eedcaf228505221e71dec323c6426894c4d28420fa20f1a03c712b7783199cde",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:206:206",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-github/src/processors/GithubDiscoveryProcessor.ts",
                "start_line": 206
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "1a55b196d5dde3a32c6681e61f50ae74e2197f66ccff996fe04a4122b297e493",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:31:35",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/config/nodeTransform.cjs",
                "start_line": 31,
                "end_line": 35
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "9a408ddecf49c1ce1c411e10e65794e5d3edb23aa70e5cfb5de92b6042cf1d59",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:36:38",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gitlab/src/providers/config.ts",
                "start_line": 36,
                "end_line": 38
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "0ca37679735d76769af7a833cd1236c1c73e1978ce4e93317e79fa5273d7c1e9",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:37:41",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/bundler/linkWorkspaces.ts",
                "start_line": 37,
                "end_line": 41
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "56309b85e1f32e0ec5214c7ea3d8e45c95824819ab151f60c807523d0648cc1f",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:39:41",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gitlab/src/providers/config.ts",
                "start_line": 39,
                "end_line": 41
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "92570f50258a453a208d37256bebd2435a4502af8ebfa54db1112b6227df3aa2",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:41:43",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/home/src/components/VisitListener.tsx",
                "start_line": 41,
                "end_line": 43
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "b4f2bc87aa0be53f603b008b40e166718e3ba37ecc5404fa7efdab7ddae54302",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:42:44",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gitlab/src/providers/config.ts",
                "start_line": 42,
                "end_line": 44
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "ffbe53097da098126cd7fa559fbe08e7037aedd4c8c54b080d321afb7975ec0d",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:51:51",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/search-react/src/components/HighlightedSearchResultText/HighlightedSearchResultText.tsx",
                "start_line": 51
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "2791363171c7bccad11326fd507e9f52eb79dc71aaa293324523c1d39e168fac",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:60:60",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/search-react/src/components/HighlightedSearchResultText/HighlightedSearchResultText.tsx",
                "start_line": 60
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "baaa1fcc63d43bdd78fd087d051a90b9a50b5fd756affee33e5a877899c16bde",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:63:65",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/home/src/components/VisitListener.tsx",
                "start_line": 63,
                "end_line": 65
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "7b796e95c037f78d082458b20c797b9ff47fdbc21e993baf65e09c92caffa293",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:66:66",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/search-react/src/components/SearchResult/SearchResult.test.tsx",
                "start_line": 66
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "25f5177e36a85c2f20e9121328309b91966eda07301ece64fdb90c22edd7fa50",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:68:68",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/builder/config.ts",
                "start_line": 68
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "be3732e957bbcefa4053cf9b8c6fd13a41b0cbcf722e67bd3a97ccc77481fb4c",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:762:762",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-github/src/providers/GithubEntityProvider.ts",
                "start_line": 762
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "940a4fd9268f20d59ac42008f602f634243b6267aec1de671b3559ab2314ca0d",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:83:83",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-bitbucket-server/src/providers/BitbucketServerEntityProviderConfig.ts",
                "start_line": 83
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "5348080b7d5a700c2db0760fafd8a263851b03acb4fbf15b20dff5bf18c31ca7",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:84:84",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-bitbucket-server/src/providers/BitbucketServerEntityProviderConfig.ts",
                "start_line": 84
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "1a2fe42d98cd14c5210baf3146b96238ea91ab38502cddf7b6dbe9788eaaadf0",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:90:90",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs/src/reader/transformers/html/transformer.ts",
                "start_line": 90
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "988f720d1c62241dbc49b1ae20b647d24c3ced8ca00c36158d87116a130e72a5",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:92:92",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs/src/reader/transformers/html/transformer.ts",
                "start_line": 92
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "d269eaeb02c513075d3266fea7a6ef8318fa8412ca8b49877a4da31370bee66b",
            "category": "sast",
            "name": "Regular expression with non-literal value",
            "description": "The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n",
            "cve": "semgrep_id:eslint.detect-non-literal-regexp:93:95",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/integration/src/awsCodeCommit/AwsCodeCommitIntegration.ts",
                "start_line": 93,
                "end_line": 95
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-regexp",
                    "value": "eslint.detect-non-literal-regexp",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-regexp",
                    "value": "detect-non-literal-regexp"
                }
            ]
        },
        {
            "id": "0262c37eeccaee45952a3d117ad3f61caf2016da59ccae3650793529c7b1147d",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "The application was found executing string comparisons using one of `===`, `!==`, `==` or `!=`\nagainst security sensitive values. String comparisons like this are not constant time, meaning\nthe\nfirst character found not to match in the two strings will immediately exit the conditional\nstatement.\nThis allows an adversary to calculate or observe small timing differences depending on the\nstrings\npassed to this comparison. This potentially allows an adversary the ability to brute force a\nstring\nthat will match the expected value by monitoring different character values.\n\nTo remediate this issue, use the `crypto.timingSafeEqual` method when comparing strings.\n\nExample using `crypto.timingSafeEqual` to safely compare strings:\n```\nfunction constantTimeIsPasswordEqual(userInput) {\n    // Retrieve the password from a secure data store such as a KMS or Hashicorp's vault.\n    const password = getPasswordFromSecureDataStore();\n    // Use crypto timingSafeEqual to ensure the comparison is done in constant time.\n    return crypto.timingSafeEqual(Buffer.from(userInput, 'utf-8'), Buffer.from(password,\n'utf-8'));\n}\n```\n\nFor more information on constant time comparison see:\n- https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b\n",
            "cve": "semgrep_id:eslint.detect-possible-timing-attacks:200:203",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend/src/database/operations/stitcher/performStitching.ts",
                "start_line": 200,
                "end_line": 203
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-possible-timing-attacks",
                    "value": "eslint.detect-possible-timing-attacks",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-possible-timing-attacks"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-possible-timing-attacks",
                    "value": "detect-possible-timing-attacks"
                }
            ]
        },
        {
            "id": "9dfe8889c75403332cc252c444171d860d4cd3130ffe51aad0477b9b2f07aac0",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "The application was found executing string comparisons using one of `===`, `!==`, `==` or `!=`\nagainst security sensitive values. String comparisons like this are not constant time, meaning\nthe\nfirst character found not to match in the two strings will immediately exit the conditional\nstatement.\nThis allows an adversary to calculate or observe small timing differences depending on the\nstrings\npassed to this comparison. This potentially allows an adversary the ability to brute force a\nstring\nthat will match the expected value by monitoring different character values.\n\nTo remediate this issue, use the `crypto.timingSafeEqual` method when comparing strings.\n\nExample using `crypto.timingSafeEqual` to safely compare strings:\n```\nfunction constantTimeIsPasswordEqual(userInput) {\n    // Retrieve the password from a secure data store such as a KMS or Hashicorp's vault.\n    const password = getPasswordFromSecureDataStore();\n    // Use crypto timingSafeEqual to ensure the comparison is done in constant time.\n    return crypto.timingSafeEqual(Buffer.from(userInput, 'utf-8'), Buffer.from(password,\n'utf-8'));\n}\n```\n\nFor more information on constant time comparison see:\n- https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b\n",
            "cve": "semgrep_id:eslint.detect-possible-timing-attacks:239:242",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/integration/src/azure/config.ts",
                "start_line": 239,
                "end_line": 242
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-possible-timing-attacks",
                    "value": "eslint.detect-possible-timing-attacks",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-possible-timing-attacks"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-possible-timing-attacks",
                    "value": "detect-possible-timing-attacks"
                }
            ]
        },
        {
            "id": "2582a0b827c95e342f191717e20757c5e562d128b334f0ff1510fead5f6609b2",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "The application was found executing string comparisons using one of `===`, `!==`, `==` or `!=`\nagainst security sensitive values. String comparisons like this are not constant time, meaning\nthe\nfirst character found not to match in the two strings will immediately exit the conditional\nstatement.\nThis allows an adversary to calculate or observe small timing differences depending on the\nstrings\npassed to this comparison. This potentially allows an adversary the ability to brute force a\nstring\nthat will match the expected value by monitoring different character values.\n\nTo remediate this issue, use the `crypto.timingSafeEqual` method when comparing strings.\n\nExample using `crypto.timingSafeEqual` to safely compare strings:\n```\nfunction constantTimeIsPasswordEqual(userInput) {\n    // Retrieve the password from a secure data store such as a KMS or Hashicorp's vault.\n    const password = getPasswordFromSecureDataStore();\n    // Use crypto timingSafeEqual to ensure the comparison is done in constant time.\n    return crypto.timingSafeEqual(Buffer.from(userInput, 'utf-8'), Buffer.from(password,\n'utf-8'));\n}\n```\n\nFor more information on constant time comparison see:\n- https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b\n",
            "cve": "semgrep_id:eslint.detect-possible-timing-attacks:42:47",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/events-backend-module-gitlab/src/http/createGitlabTokenValidator.ts",
                "start_line": 42,
                "end_line": 47
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-possible-timing-attacks",
                    "value": "eslint.detect-possible-timing-attacks",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-possible-timing-attacks"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-possible-timing-attacks",
                    "value": "detect-possible-timing-attacks"
                }
            ]
        },
        {
            "id": "93aeb79d5120d57e9d9f52baa9836c90f1ef59d0eb6059edf7c6be020bfcdf13",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "The application was found executing string comparisons using one of `===`, `!==`, `==` or `!=`\nagainst security sensitive values. String comparisons like this are not constant time, meaning\nthe\nfirst character found not to match in the two strings will immediately exit the conditional\nstatement.\nThis allows an adversary to calculate or observe small timing differences depending on the\nstrings\npassed to this comparison. This potentially allows an adversary the ability to brute force a\nstring\nthat will match the expected value by monitoring different character values.\n\nTo remediate this issue, use the `crypto.timingSafeEqual` method when comparing strings.\n\nExample using `crypto.timingSafeEqual` to safely compare strings:\n```\nfunction constantTimeIsPasswordEqual(userInput) {\n    // Retrieve the password from a secure data store such as a KMS or Hashicorp's vault.\n    const password = getPasswordFromSecureDataStore();\n    // Use crypto timingSafeEqual to ensure the comparison is done in constant time.\n    return crypto.timingSafeEqual(Buffer.from(userInput, 'utf-8'), Buffer.from(password,\n'utf-8'));\n}\n```\n\nFor more information on constant time comparison see:\n- https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b\n",
            "cve": "semgrep_id:eslint.detect-possible-timing-attacks:55:57",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-test-utils/src/next/services/MockHttpAuthService.ts",
                "start_line": 55,
                "end_line": 57
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-possible-timing-attacks",
                    "value": "eslint.detect-possible-timing-attacks",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-possible-timing-attacks"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-possible-timing-attacks",
                    "value": "detect-possible-timing-attacks"
                }
            ]
        },
        {
            "id": "cbcecd9f0bec4c8c0af8ad9b718fc15e1d762d85510f28eb6a5bcad40a4527f3",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "The application was found executing string comparisons using one of `===`, `!==`, `==` or `!=`\nagainst security sensitive values. String comparisons like this are not constant time, meaning\nthe\nfirst character found not to match in the two strings will immediately exit the conditional\nstatement.\nThis allows an adversary to calculate or observe small timing differences depending on the\nstrings\npassed to this comparison. This potentially allows an adversary the ability to brute force a\nstring\nthat will match the expected value by monitoring different character values.\n\nTo remediate this issue, use the `crypto.timingSafeEqual` method when comparing strings.\n\nExample using `crypto.timingSafeEqual` to safely compare strings:\n```\nfunction constantTimeIsPasswordEqual(userInput) {\n    // Retrieve the password from a secure data store such as a KMS or Hashicorp's vault.\n    const password = getPasswordFromSecureDataStore();\n    // Use crypto timingSafeEqual to ensure the comparison is done in constant time.\n    return crypto.timingSafeEqual(Buffer.from(userInput, 'utf-8'), Buffer.from(password,\n'utf-8'));\n}\n```\n\nFor more information on constant time comparison see:\n- https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b\n",
            "cve": "semgrep_id:eslint.detect-possible-timing-attacks:692:694",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 692,
                "end_line": 694
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-possible-timing-attacks",
                    "value": "eslint.detect-possible-timing-attacks",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-possible-timing-attacks"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-possible-timing-attacks",
                    "value": "detect-possible-timing-attacks"
                }
            ]
        },
        {
            "id": "e755ba392065cb2e62685e1c7446df15f0d10f2bffbf5a4e838a7837fd70a60d",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "The application was found executing string comparisons using one of `===`, `!==`, `==` or `!=`\nagainst security sensitive values. String comparisons like this are not constant time, meaning\nthe\nfirst character found not to match in the two strings will immediately exit the conditional\nstatement.\nThis allows an adversary to calculate or observe small timing differences depending on the\nstrings\npassed to this comparison. This potentially allows an adversary the ability to brute force a\nstring\nthat will match the expected value by monitoring different character values.\n\nTo remediate this issue, use the `crypto.timingSafeEqual` method when comparing strings.\n\nExample using `crypto.timingSafeEqual` to safely compare strings:\n```\nfunction constantTimeIsPasswordEqual(userInput) {\n    // Retrieve the password from a secure data store such as a KMS or Hashicorp's vault.\n    const password = getPasswordFromSecureDataStore();\n    // Use crypto timingSafeEqual to ensure the comparison is done in constant time.\n    return crypto.timingSafeEqual(Buffer.from(userInput, 'utf-8'), Buffer.from(password,\n'utf-8'));\n}\n```\n\nFor more information on constant time comparison see:\n- https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b\n",
            "cve": "semgrep_id:eslint.detect-possible-timing-attacks:98:104",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AzureUrlReader.test.ts",
                "start_line": 98,
                "end_line": 104
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-possible-timing-attacks",
                    "value": "eslint.detect-possible-timing-attacks",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-possible-timing-attacks"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-possible-timing-attacks",
                    "value": "detect-possible-timing-attacks"
                }
            ]
        },
        {
            "id": "ce73b1ea173a239eb738876a5a5aeda7c5ed66889749903f9c2ee5ddaf8bdd54",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:142:142",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/home/src/components/CustomHomepage/CustomHomepageGrid.tsx",
                "start_line": 142
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "24cdc5afae498df39ad69a2338ffb4659a877a29cf18dd1cb12e80b99744aad1",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:217:217",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/events-backend/src/service/hub/DatabaseEventBusStore.test.ts",
                "start_line": 217
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "92b8f90272e5042a09def8727c1b61da69cab26ffb53252830bcb80376349942",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:227:227",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/home/src/components/CustomHomepage/CustomHomepageGrid.tsx",
                "start_line": 227
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "5fdb1c793cec797f998aa2f67cb692888017c0571dfd42b1653c6b625ba8104a",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:23:23",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/home/src/homePageComponents/WelcomeTitle/timeUtil.ts",
                "start_line": 23
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "dfa2395accb6c6fa74c10996c8bb453abfbd1c0d82dec9b0c8754beb11a79cc5",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:24:24",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/home/src/api/VisitsWebStorageApi.test.ts",
                "start_line": 24
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "18db818250a7444bf66b62e4dd480be1d32266e0fb474e3b248dda28849b5256",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:256:256",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/events-backend/src/service/hub/createEventBusRouter.ts",
                "start_line": 256
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "7560fd25350d2f3b0ff18ceaeb5d2eb5204384b6ac92eda25cf71e70b7e3c526",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:25:25",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/home/src/api/VisitsStorageApi.test.ts",
                "start_line": 25
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "aeafe9c91f3997b91e533e10f7b9614afa75a181f0c0b6b597d91b1e2c037f26",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:33:33",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/notifications-backend/dev/index.ts",
                "start_line": 33
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "3527a1bce8fdbbac10cc95b9e78c50a3998476b0bd7455e15f29da1b2ded43fb",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:34:34",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend/src/processing/refresh.ts",
                "start_line": 34
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "b8db2fc3d8dc95260571063f9debb23cd200ca30ee4ca2f2b5365fee1358e01f",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:44:44",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/notifications-backend/dev/index.ts",
                "start_line": 44
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "545df33ce3bdff2adde8dbafc69037f2585558b78dc4174a9898a952a68f5b45",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:480:480",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/search-backend/src/service/AuthorizedSearchEngine.test.ts",
                "start_line": 480
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "83abe43d92b89fc111d34e5241a84903caf8dbbe4ee7e607f3585573a8b8f6d9",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:49:49",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/core-app-api/src/apis/implementations/IdentityApi/startCookieAuthRefresh.ts",
                "start_line": 49
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "cb1b264579d2dcecb0a13ec523d1a44255fc87b75551c480e5586c83a7550ddc",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:55:55",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/notifications-backend/dev/index.ts",
                "start_line": 55
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "f8109a49b80ec1dc30c1542aa5d76ea8519e6c0884108576730f8c66e7174992",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:62:62",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/notifications-backend/dev/index.ts",
                "start_line": 62
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "8971b15a916445ac874005bd03ebe89671fadf425472cb06d556d9a4c93b9bd6",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:62:62",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/core-components/src/layout/ItemCard/ItemCard.stories.tsx",
                "start_line": 62
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "7de70b99e24133fa6961a97d6da654d4a1c9a35d358ec40f099d39dd58a2dc35",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:69:69",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend/src/service/response/write.ts",
                "start_line": 69
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "827fdaf7b5d094929c797c0c2d6a7de4dd8d9a9bf16e48a1862a88b53987ec42",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:69:69",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/notifications-backend/dev/index.ts",
                "start_line": 69
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "a17204795295d61b14303c7731e2181b3edd84fb592a27c852ffc2fb5e97526c",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:72:72",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/canon/src/components/Inline/Inline.stories.tsx",
                "start_line": 72
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "b332128837c549ee72ba54b30ad3fb2dae9a89ef0bf7f174ccb62501b7786bec",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:73:73",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/canon/src/components/Inline/Inline.stories.tsx",
                "start_line": 73
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "ff53ba4e4bf71d7581975d4fbedebf1c384c79983335814bb448e3d1bb3f7107",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:85:85",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/auth-react/src/hooks/useCookieAuthRefresh/useCookieAuthRefresh.tsx",
                "start_line": 85
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "72ded9d770e0510577def2d280d6f17394c85a34439497445df86b5521d1a113",
            "category": "sast",
            "name": "Use of cryptographically weak pseudo-random number generator (PRNG)",
            "description": "This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:98:98",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/core-components/src/layout/ItemCard/ItemCard.stories.tsx",
                "start_line": 98
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator",
                    "value": "nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"
                },
                {
                    "type": "cwe",
                    "name": "CWE-338",
                    "value": "338",
                    "url": "https://cwe.mitre.org/data/definitions/338.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator",
                    "value": "crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."
                }
            ]
        },
        {
            "id": "88676e2f40097aa4820b550216c0c0a508a416813eafb3a3ebf8a70afd2bdca2",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:163:163",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/lint.ts",
                "start_line": 163
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "2407f07df6dbfbdffdcba086ef899454408f4d8b5313068da5eae2c3329e4253",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:173:173",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/lint.ts",
                "start_line": 173
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "d6ff71a1ebb213bf29ce3ed45a61acdd08f54fbe6503859113ab5a9b2f965f27",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:175:175",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/lint.ts",
                "start_line": 175
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "61d68cf8276636b0704c467fef85a4733717264fee1c66c89f2065e3045400f9",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:181:181",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/lint.ts",
                "start_line": 181
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "93c1054a18f463dbfdb9d267f3f4e68dbd689da9c21ba6b7d0c886324f88e66a",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:247:247",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli-node/src/monorepo/Lockfile.ts",
                "start_line": 247
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "6f66770fc77b6392f6a574a6c0349dbe35c692336fc0ecd3ebce8803c521a29b",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:263:263",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli-node/src/monorepo/Lockfile.ts",
                "start_line": 263
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "063bb658a91250483976be282bbe0271494d8ff5446325658ece9937714166d7",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:267:267",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli-node/src/monorepo/Lockfile.ts",
                "start_line": 267
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "4dc2a69cb2e5bcf803b8c67f21fd444ed803d218a5da818c86b153a631a183be",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:340:340",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/test.ts",
                "start_line": 340
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "ff4cee8f5d936a7fa39eba2434c6b615616d6616b7d87bda32f31e8dcc062505",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:341:341",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/test.ts",
                "start_line": 341
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "0ee7d15d19ff8426ba56d18ea748b5e53bae7408ad45f1d3e655087b64388f86",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:343:343",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/test.ts",
                "start_line": 343
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "57ca9e954530ee5e86933f4e7fbfded76e91490c20c8859cfcf7506aa01a36cc",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:94:94",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/lint.ts",
                "start_line": 94
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "e5d74572f2833bd444602aa7ce156dfd019a504d8730a6d8cf12ea7ec1246d07",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:96:96",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/lint.ts",
                "start_line": 96
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "54074818afc4b2c32b1b192f0a9c9e85adb36ec754c6144fe81d5159fca9525a",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:98:98",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/lint.ts",
                "start_line": 98
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "5a644d1148602c4963fc091d84706241c894fe691b2633014ec0138b80c3c469",
            "category": "sast",
            "name": "Use of weak hash",
            "description": "The SHA-1 hashing algorithm is no longer considered secure for\ncryptographic applications due to its vulnerability to collision attacks,\nwhere two different inputs produce the same output hash. SHA-1's\nsusceptibility to collision attacks undermines the security of\ncryptographic operations, allowing attackers to forge signatures or\nmanipulate data without detection. This poses significant risks in\nauthentication systems, data integrity validations, and secure\ncommunications. \n\nRemediation: To mitigate this vulnerability, replace the SHA1 hashing \nalgorithm with  stronger cryptographic hash functions, such as SHA-256 \nor SHA-3. These  algorithms offer significantly improved security and \nare resistant to  collision attacks, making them suitable for cryptographic \npurposes in  modern applications.\n\nSecure Code example:  \n```  \nconst crypto = require('crypto');  \nconst hash = crypto.createHash('sha256').update('sensitive data').digest('hex');  \nconsole.log(hash);   \n```\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_sha1:99:99",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/lint.ts",
                "start_line": 99
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_sha1",
                    "value": "nodejs_scan.javascript-crypto-rule-node_sha1"
                },
                {
                    "type": "cwe",
                    "name": "CWE-328",
                    "value": "328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_sha1",
                    "value": "SHA1 is a a weak hash which is known to have collision. Use a strong hashing function."
                }
            ]
        },
        {
            "id": "624ddfc2dae6a598be6acd5d02d3e84fbed9af7fa782369a1e3a3888c08d5d28",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_timing_attack:200:203",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend/src/database/operations/stitcher/performStitching.ts",
                "start_line": 200,
                "end_line": 203
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_timing_attack",
                    "value": "nodejs_scan.javascript-crypto-rule-node_timing_attack"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_timing_attack",
                    "value": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'"
                }
            ]
        },
        {
            "id": "e877524ba390273ce67b111da3270ce639bd1ebb78b8a4b31e5efe52f0c51eaa",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_timing_attack:239:242",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/integration/src/azure/config.ts",
                "start_line": 239,
                "end_line": 242
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_timing_attack",
                    "value": "nodejs_scan.javascript-crypto-rule-node_timing_attack"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_timing_attack",
                    "value": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'"
                }
            ]
        },
        {
            "id": "e6471e2b93876e9255d7eaa2efd896aeba35517c41744ebdac23a992e57fd8e9",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_timing_attack:42:47",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/events-backend-module-gitlab/src/http/createGitlabTokenValidator.ts",
                "start_line": 42,
                "end_line": 47
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_timing_attack",
                    "value": "nodejs_scan.javascript-crypto-rule-node_timing_attack"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_timing_attack",
                    "value": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'"
                }
            ]
        },
        {
            "id": "f08a9d5a7bdda163c6974adc179b457daaa1cd2add399f35a475eed9b52b9d42",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_timing_attack:55:57",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-test-utils/src/next/services/MockHttpAuthService.ts",
                "start_line": 55,
                "end_line": 57
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_timing_attack",
                    "value": "nodejs_scan.javascript-crypto-rule-node_timing_attack"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_timing_attack",
                    "value": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'"
                }
            ]
        },
        {
            "id": "4dc1a1509101ce2732fe908059396cf7c90f2feb7058921b484a857b75f7eb38",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_timing_attack:692:694",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/repo-tools/src/commands/api-reports/api-extractor.ts",
                "start_line": 692,
                "end_line": 694
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_timing_attack",
                    "value": "nodejs_scan.javascript-crypto-rule-node_timing_attack"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_timing_attack",
                    "value": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'"
                }
            ]
        },
        {
            "id": "f09ea228c410ebcc467cc8324a983b526598e2681469533c65bf1a88f6d5cfd3",
            "category": "sast",
            "name": "Observable timing discrepancy",
            "description": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'\n",
            "cve": "semgrep_id:nodejs_scan.javascript-crypto-rule-node_timing_attack:98:104",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/entrypoints/urlReader/lib/AzureUrlReader.test.ts",
                "start_line": 98,
                "end_line": 104
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-crypto-rule-node_timing_attack",
                    "value": "nodejs_scan.javascript-crypto-rule-node_timing_attack"
                },
                {
                    "type": "cwe",
                    "name": "CWE-208",
                    "value": "208",
                    "url": "https://cwe.mitre.org/data/definitions/208.html"
                },
                {
                    "type": "owasp",
                    "name": "A02:2021 - Cryptographic Failures",
                    "value": "A02:2021"
                },
                {
                    "type": "owasp",
                    "name": "A3:2017 - Sensitive Data Exposure",
                    "value": "A3:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-crypto-rule-node_timing_attack",
                    "value": "'String comparisons using ''==='', ''!=='', ''!='' and ''=='' is vulnerable to timing attacks. More info: https://snyk.io/blog/node-js-timing-attack-ccc-ctf/'"
                }
            ]
        },
        {
            "id": "ad0a7b9699da8520475d333324edfe047d9c140eb683e712176b12aa6f5b693d",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:140:140",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-node/src/ServerPermissionClient.test.ts",
                "start_line": 140
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "a9f78487232fbeb1d82e40dc0d54eab5093e99590d6b3f69b41f5137f0a7c7e1",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:150:150",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-common/src/PermissionClient.test.ts",
                "start_line": 150
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "6ea3e29f910d907188a170680395103629f13b8072cc5b96041eb656fe95d2ff",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:168:168",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-common/src/PermissionClient.test.ts",
                "start_line": 168
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "083c904a24aa84847ab6428fdc7a06662878e978e9fb559f0d182eec2ba28cc7",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:192:192",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-common/src/PermissionClient.test.ts",
                "start_line": 192
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "a7192e3d68d18122587e62b35161b425b6b297962c1dc03ae9973fbeab476b89",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:221:221",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-common/src/PermissionClient.test.ts",
                "start_line": 221
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "bbdfec8a7fd687a9c3fad576632b9d4c064b97db4d3ccca9ecb990430e6ffbfe",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:229:229",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/events-backend/src/service/hub/createEventBusRouter.ts",
                "start_line": 229
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "7c46d103abd02f7ea3abd77e94f4a2a2f92fa66aa84946c1df986ee1f1d07460",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:316:316",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-common/src/PermissionClient.test.ts",
                "start_line": 316
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "93ca890298e26def4314a63beddafcf3aff3ce65adab7ce2667df4047eb880f9",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:367:367",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-common/src/PermissionClient.test.ts",
                "start_line": 367
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "90ff4c0695fff6840dfd2c10e3a5387ec4c0976521806bd3986199e031f624f4",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:387:387",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-common/src/PermissionClient.test.ts",
                "start_line": 387
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "95c70c529da485ab96ee4e96fff4c6f5399a30bb3f29abc5d4829dd678f14612",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:416:416",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-common/src/PermissionClient.test.ts",
                "start_line": 416
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "3e8f3f6aae721fbf31bbc4608afedc0e9add6bcde253f78cca33740889ba6da2",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:441:441",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-node/src/integration/createPermissionIntegrationRouter.ts",
                "start_line": 441
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "f10786e8a7212320212546ba975e69084372199ae3c879db6d0501b6a4487cb7",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:463:463",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-node/src/integration/createPermissionIntegrationRouter.ts",
                "start_line": 463
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "083da7032173dec7287f26793cc4c4a87def7661e9fa28550353202809f0f53e",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:472:472",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-node/src/integration/createPermissionIntegrationRouter.ts",
                "start_line": 472
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "72f283c098db4ec61a616ed995590ceb69b6bda2206f7dc45301937cf98d91e8",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:479:479",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/service/router.ts",
                "start_line": 479
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "23124eea1708df77c92c2f20d601768b451e3c1f048d57ecbbbc46fed03e4f4e",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:554:554",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/service/router.ts",
                "start_line": 554
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "ebef0d0249f5767c86a262ab8502e522fce52235a8ae953ef1c8105200e3b3cb",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:59:107",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/core-app-api/src/routing/FlatRoutes.tsx",
                "start_line": 59,
                "end_line": 107
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "58367305c3475c076ec4cc5cc4bd1b40a8560205ab51d18585b688add3ddf40a",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:610:610",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/service/router.ts",
                "start_line": 610
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "c8c53e0713e061b52ca46c28a52ad39befebf32c390690c6f6812a036edd978a",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:62:62",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-common/src/PermissionClient.test.ts",
                "start_line": 62
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "5a12d8c65449fecb3ac77de9354441ecf848627b1ed80aca28ab31f5028091dd",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:69:69",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/permission-node/src/ServerPermissionClient.test.ts",
                "start_line": 69
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "cabb6fd92b75d6c387f4a0d954d1a81c9090fd0b4d99ab5418c4be29f349c0c8",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:822:822",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/service/router.ts",
                "start_line": 822
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "b17fa43fea3667ba62065bb72f0e19efcb30980d1e7e059cf4473860b8c283d5",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:856:856",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/service/router.ts",
                "start_line": 856
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "7d1e07a88b26f22cb35cb02a0cae172f24c75b32f48b58d5ffd4234a78049886",
            "category": "sast",
            "name": "Unchecked input for loop condition",
            "description": "This application is looping over user controlled objects, which can lead to a layer 7 denial of service vulnerability.\n\nA layer 7 denial of service attack refers to overloading the application layer of the OSI model, typically layer 7. \nThis can happen when user-controlled input such as objects, arrays, strings, etc. are iterated or looped over without proper validation or limits in place.\n\nFor example, if a user can control the size of an array or object passed into the application, \nthey could create an extremely large input that gets looped over. This would consume excessive CPU cycles or memory, \npotentially crashing or slowing down the application.\n\nTo prevent this, limits should be set on the number of iterations, input sizes, recursion depth, etc.\n\nSample case of secure array looped over with user-controlled input\n```\n// Potential DoS if req.body.list.length is large.\napp.post('/dos/layer7-object-dos/for-loop/1', function (req, res) {\n    var list = req.body.list;\n    for (let i = 0; i \u003c= 10; i++) {\n        if(!list[i]){\n          // return;\n        }  \n    }\n    res.send(\"res\")\n});\n```\n\nImplementing protections against layer 7 denial of service attacks is important for securing modern web applications and APIs.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-layer7_object_dos:870:870",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/scaffolder-backend/src/service/router.ts",
                "start_line": 870
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-layer7_object_dos",
                    "value": "nodejs_scan.javascript-dos-rule-layer7_object_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-606",
                    "value": "606",
                    "url": "https://cwe.mitre.org/data/definitions/606.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-layer7_object_dos",
                    "value": "Layer7 Denial of Service. Looping over user controlled objects can result in DoS."
                }
            ]
        },
        {
            "id": "e13b7676db0fca0d106eb2768fa58763bd1a7ccda1543e7af9cbb2129786a922",
            "category": "sast",
            "name": "Incorrect regular expression",
            "description": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:110:110",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/builder/config.ts",
                "start_line": 110
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-regex_dos",
                    "value": "nodejs_scan.javascript-dos-rule-regex_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-regex_dos",
                    "value": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."
                }
            ]
        },
        {
            "id": "85c8835249bb333166c0568e27597f01525fc530436905d2534aff6d0ac16934",
            "category": "sast",
            "name": "Incorrect regular expression",
            "description": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:156:156",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/core-components/src/components/LogViewer/AnsiProcessor.ts",
                "start_line": 156
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-regex_dos",
                    "value": "nodejs_scan.javascript-dos-rule-regex_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-regex_dos",
                    "value": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."
                }
            ]
        },
        {
            "id": "95a0ac2e8e56bcdc3f1d69bbf9c1e2e23642ec4dfd44725837f021e1e685efa8",
            "category": "sast",
            "name": "Incorrect regular expression",
            "description": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:232:232",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/builder/config.ts",
                "start_line": 232
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-regex_dos",
                    "value": "nodejs_scan.javascript-dos-rule-regex_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-regex_dos",
                    "value": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."
                }
            ]
        },
        {
            "id": "8d0a26236ba1f1e2a8f60f53a45f7ff8858da716dce78ce583cf999b6c899f14",
            "category": "sast",
            "name": "Incorrect regular expression",
            "description": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:26:26",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/config/jestSwcTransform.js",
                "start_line": 26
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-regex_dos",
                    "value": "nodejs_scan.javascript-dos-rule-regex_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-regex_dos",
                    "value": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."
                }
            ]
        },
        {
            "id": "011d523728129cc5c0cf4c88a35e588b74626069cce93cd0616b0397f5550c91",
            "category": "sast",
            "name": "Incorrect regular expression",
            "description": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:32:32",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/config/jestSucraseTransform.js",
                "start_line": 32
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-regex_dos",
                    "value": "nodejs_scan.javascript-dos-rule-regex_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-regex_dos",
                    "value": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."
                }
            ]
        },
        {
            "id": "63f174a81f8ff71254f3db8bf8409aa6b626ab2aa38ed743cc73f27e6905287c",
            "category": "sast",
            "name": "Incorrect regular expression",
            "description": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:39:39",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/config/nodeTransform.cjs",
                "start_line": 39
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-regex_dos",
                    "value": "nodejs_scan.javascript-dos-rule-regex_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-regex_dos",
                    "value": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."
                }
            ]
        },
        {
            "id": "876895069d6e0521c92417ab2fff90f311a2e38682a4e77b64faafd11a443979",
            "category": "sast",
            "name": "Incorrect regular expression",
            "description": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:451:451",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/catalog-backend-module-gitlab/src/providers/GitlabDiscoveryEntityProvider.ts",
                "start_line": 451
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-regex_dos",
                    "value": "nodejs_scan.javascript-dos-rule-regex_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-regex_dos",
                    "value": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."
                }
            ]
        },
        {
            "id": "e22e3122115e1effddbd35de129fa241d0bf990b6997cdb2294c9e4a9a3dc0b4",
            "category": "sast",
            "name": "Incorrect regular expression",
            "description": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n",
            "cve": "semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:71:71",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/test-utils/src/testUtils/apis/ErrorApi/MockErrorApi.ts",
                "start_line": 71
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-dos-rule-regex_dos",
                    "value": "nodejs_scan.javascript-dos-rule-regex_dos"
                },
                {
                    "type": "cwe",
                    "name": "CWE-185",
                    "value": "185",
                    "url": "https://cwe.mitre.org/data/definitions/185.html"
                },
                {
                    "type": "owasp",
                    "name": "A05:2021 - Security Misconfiguration",
                    "value": "A05:2021"
                },
                {
                    "type": "owasp",
                    "name": "A6:2017 - Security Misconfiguration",
                    "value": "A6:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-dos-rule-regex_dos",
                    "value": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."
                }
            ]
        },
        {
            "id": "45a5e3f36bc3d6506e0ce123def118fda9b0eaadc57065b6b5ca0305d95b126f",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "'Path constructed with user input can result in Path Traversal. Ensure that user input does not reach `join()` or `resolve()`. '\n",
            "cve": "semgrep_id:nodejs_scan.javascript-traversal-rule-join_resolve_path_traversal:108:111",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/prepare-release.js",
                "start_line": 108,
                "end_line": 111
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-traversal-rule-join_resolve_path_traversal",
                    "value": "nodejs_scan.javascript-traversal-rule-join_resolve_path_traversal"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-traversal-rule-join_resolve_path_traversal",
                    "value": "'Path constructed with user input can result in Path Traversal. Ensure that user input does not reach `join()` or `resolve()`. '"
                }
            ]
        },
        {
            "id": "a06ed246a7ca9b7f3c99ecb721458eddcd7a12ee969e070108270d44472b6709",
            "category": "sast",
            "name": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
            "description": "'Path constructed with user input can result in Path Traversal. Ensure that user input does not reach `join()` or `resolve()`. '\n",
            "cve": "semgrep_id:nodejs_scan.javascript-traversal-rule-join_resolve_path_traversal:331:331",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/prepare-release.js",
                "start_line": 331
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-traversal-rule-join_resolve_path_traversal",
                    "value": "nodejs_scan.javascript-traversal-rule-join_resolve_path_traversal"
                },
                {
                    "type": "cwe",
                    "name": "CWE-22",
                    "value": "22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                },
                {
                    "type": "owasp",
                    "name": "A01:2021 - Broken Access Control",
                    "value": "A01:2021"
                },
                {
                    "type": "owasp",
                    "name": "A5:2017 - Broken Access Control",
                    "value": "A5:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-traversal-rule-join_resolve_path_traversal",
                    "value": "'Path constructed with user input can result in Path Traversal. Ensure that user input does not reach `join()` or `resolve()`. '"
                }
            ]
        },
        {
            "id": "157b3970e889ce13ffb380232b2c0f83eba798554a170cf92618f0074cac0ebe",
            "category": "sast",
            "name": "Improper neutralization of input during web page generation ('Cross-site Scripting')",
            "description": "This application accepts user input directly from the client side without validation. \nThis could lead to Cross Site Scripting (XSS) if the input contains malicious script code and \nthe application server does not properly escape or sanitize the output.  \nConsider encoding input data before sending it to the client side.  \n\n```\n// safe method of sending user input data\nrouter.get('/safe/1', (req, res) =\u003e {\n  var name = encodeURI(req.query.name); \n  res.send(name);\n})\n```\n\nXSS is an attack that exploits a web application or system to treat user input as markup or script code. \nIt is important to encode the data depending on the specific context in which it is used. \n",
            "cve": "semgrep_id:nodejs_scan.javascript-xss-rule-express_xss:265:265",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/openStackSwift.ts",
                "start_line": 265
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-xss-rule-express_xss",
                    "value": "nodejs_scan.javascript-xss-rule-express_xss"
                },
                {
                    "type": "cwe",
                    "name": "CWE-79",
                    "value": "79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A7:2017 - Cross-Site Scripting (XSS)",
                    "value": "A7:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-xss-rule-express_xss",
                    "value": "Untrusted User Input in Response will result in Reflected Cross Site Scripting Vulnerability."
                }
            ]
        },
        {
            "id": "eabe5f56b85a8587d99317f8d65014a38ee01a16e2573e9670e4e2dff08fc6c3",
            "category": "sast",
            "name": "Improper neutralization of input during web page generation ('Cross-site Scripting')",
            "description": "This application accepts user input directly from the client side without validation. \nThis could lead to Cross Site Scripting (XSS) if the input contains malicious script code and \nthe application server does not properly escape or sanitize the output.  \nConsider encoding input data before sending it to the client side.  \n\n```\n// safe method of sending user input data\nrouter.get('/safe/1', (req, res) =\u003e {\n  var name = encodeURI(req.query.name); \n  res.send(name);\n})\n```\n\nXSS is an attack that exploits a web application or system to treat user input as markup or script code. \nIt is important to encode the data depending on the specific context in which it is used. \n",
            "cve": "semgrep_id:nodejs_scan.javascript-xss-rule-express_xss:480:480",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/techdocs-node/src/stages/publish/awsS3.ts",
                "start_line": 480
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-xss-rule-express_xss",
                    "value": "nodejs_scan.javascript-xss-rule-express_xss"
                },
                {
                    "type": "cwe",
                    "name": "CWE-79",
                    "value": "79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A7:2017 - Cross-Site Scripting (XSS)",
                    "value": "A7:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-xss-rule-express_xss",
                    "value": "Untrusted User Input in Response will result in Reflected Cross Site Scripting Vulnerability."
                }
            ]
        },
        {
            "id": "ccd9f2e80e2412c801670ab8b7dc79f5016dd0ba317392a1cab2afff69bde93e",
            "category": "sast",
            "name": "Improper neutralization of input during web page generation ('Cross-site Scripting')",
            "description": "This application accepts user input directly from the client side without validation. \nThis could lead to Cross Site Scripting (XSS) if the input contains malicious script code and \nthe application server does not properly escape or sanitize the output.  \nConsider encoding input data before sending it to the client side.  \n\n```\n// safe method of sending user input data\nrouter.get('/safe/1', (req, res) =\u003e {\n  var name = encodeURI(req.query.name); \n  res.send(name);\n})\n```\n\nXSS is an attack that exploits a web application or system to treat user input as markup or script code. \nIt is important to encode the data depending on the specific context in which it is used. \n",
            "cve": "semgrep_id:nodejs_scan.javascript-xss-rule-express_xss:60:60",
            "severity": "Medium",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "plugins/app-backend/src/lib/assets/createStaticAssetMiddleware.ts",
                "start_line": 60
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "nodejs_scan.javascript-xss-rule-express_xss",
                    "value": "nodejs_scan.javascript-xss-rule-express_xss"
                },
                {
                    "type": "cwe",
                    "name": "CWE-79",
                    "value": "79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A7:2017 - Cross-Site Scripting (XSS)",
                    "value": "A7:2017"
                },
                {
                    "type": "njsscan_rule_type",
                    "name": "NodeJS Scan ID javascript-xss-rule-express_xss",
                    "value": "Untrusted User Input in Response will result in Reflected Cross Site Scripting Vulnerability."
                }
            ]
        },
        {
            "id": "b4d8d8978bc14660107944a5d21f046b6e6912cd9260c719186b2d50b97f32c2",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:129:131",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/PackageDiscoveryService.ts",
                "start_line": 129,
                "end_line": 131
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "1fa26330b2f703227910b21b466273356e9dee85f37076e73ef1415f149a8ac5",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:145:145",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/config/jest.js",
                "start_line": 145
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "bb5ce9b47dd89236b5bda8d1da178c4fcd3615f5eb54ea04ee9deaab37a76604",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:147:147",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/config/jest.js",
                "start_line": 147
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "4a473b0ee2b8023c7084c23acd068cb8a91fe7c9abd8c718096eb55118ad0f8d",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:155:155",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/PackageDiscoveryService.ts",
                "start_line": 155
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "caaadac775b8fb08f82008cda6ac28f528571dd591632a21fb675ad9df582fa7",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:162:162",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 162
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "f5e9c213c69e1f79c60a23f789520b1b016ae02b53eb695a4d0a80da805696e2",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:173:173",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/e2e-test/src/commands/run.ts",
                "start_line": 173
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "81f11dd036e89a2a776029656ef42bac447ce00e3a63f11a598869c9f67786fc",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:195:195",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/fix.ts",
                "start_line": 195
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "c678bee1a8b6e814baa2a72d2cbaf2dedea5995bcaca5b1377c7e6e796b7d66e",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:296:296",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/config/eslint-factory.js",
                "start_line": 296
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "08f80eac121c3357047b2989847e5d46c2502e42d2336db177ddce1d850e80cd",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:352:352",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/bundler/server.ts",
                "start_line": 352
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "ac9ef4df7a69bfc3c0521714ce3beba3ddcc872f45264f6c49ca4aa4cab1dce8",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:42:42",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/migrate/packageLintConfigs.ts",
                "start_line": 42
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "1966448ba522a6f3ef9de90d02d039ceccfce4f5c85f09a849365deaf98157a1",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:45:45",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/commands/repo/fix.ts",
                "start_line": 45
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "2db8bd9053248cb4d3c8097d78240c72e856184edd8e02005e4e004f3740e33a",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:681:681",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-dynamic-feature-service/src/manager/plugin-manager.test.ts",
                "start_line": 681
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "c2a68d470a50aebfc54007d5bc47a436dd157bec0c1281c7556b0b78312e0ebb",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:77:77",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "scripts/generate-merge-message.js",
                "start_line": 77
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "f0397fa2deff68bfaf857a977a7aef62082cccfd0d01d236cf017f1a573b0fea",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:82:85",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/cli/src/lib/bundler/packageDetection.ts",
                "start_line": 82,
                "end_line": 85
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        },
        {
            "id": "fb07e5fc34730164813e8240acde3345e048d008b7ce6b7830989e8ab1b4e501",
            "category": "sast",
            "name": "Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
            "description": "The application was found to dynamically import a module by calling `require` using a\nnon-literal string. An adversary might be able to read the first line of\narbitrary files. If they had write access to the file system, they may also be able to\nexecute arbitrary code.\n\nTo remediate this issue, use a hardcoded string literal when calling `require`. Never call it\nit with dynamically created variables or user-supplied data.\n",
            "cve": "semgrep_id:eslint.detect-non-literal-require:89:89",
            "severity": "Low",
            "scanner": {
                "id": "semgrep",
                "name": "Semgrep"
            },
            "location": {
                "file": "packages/backend-defaults/src/PackageDiscoveryService.ts",
                "start_line": 89
            },
            "identifiers": [
                {
                    "type": "semgrep_id",
                    "name": "eslint.detect-non-literal-require",
                    "value": "eslint.detect-non-literal-require",
                    "url": "https://semgrep.dev/r/gitlab.eslint.detect-non-literal-require"
                },
                {
                    "type": "cwe",
                    "name": "CWE-95",
                    "value": "95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                },
                {
                    "type": "owasp",
                    "name": "A03:2021 - Injection",
                    "value": "A03:2021"
                },
                {
                    "type": "owasp",
                    "name": "A1:2017 - Injection",
                    "value": "A1:2017"
                },
                {
                    "type": "eslint_rule_id",
                    "name": "ESLint rule ID/detect-non-literal-require",
                    "value": "detect-non-literal-require"
                }
            ]
        }
    ],
    "scan": {
        "analyzer": {
            "id": "semgrep",
            "name": "Semgrep",
            "url": "https://gitlab.com/gitlab-org/security-products/analyzers/semgrep",
            "vendor": {
                "name": "GitLab"
            },
            "version": "5.25.0"
        },
        "scanner": {
            "id": "semgrep",
            "name": "Semgrep",
            "url": "https://github.com/returntocorp/semgrep",
            "vendor": {
                "name": "GitLab"
            },
            "version": "1.74.0"
        },
        "type": "sast",
        "start_time": "2025-01-07T03:32:11",
        "end_time": "2025-01-07T03:35:57",
        "status": "success"
    }
}